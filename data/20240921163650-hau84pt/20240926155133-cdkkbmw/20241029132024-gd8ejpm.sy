{"ID":"20241029132024-gd8ejpm","Spec":"1","Type":"NodeDocument","Properties":{"custom-common-Halo-yaml":"---_esc_newline_created: '2024-10-29 13:20:24'_esc_newline_updated: '2024-10-29 23:43:47'_esc_newline_title: JVM面经_esc_newline_slug: jvm-face-meridian-zkdonu_esc_newline_permalink: siyuan://blocks/20241029132024-gd8ejpm_esc_newline_tags:_esc_newline_  - 面经_esc_newline_categories: []_esc_newline_---","custom-picgo-file-map-key":"\u0026#123;\u0026quot;82991da00250d32cb9b46c1f389d74cc\u0026quot;:\u0026#123;\u0026quot;name\u0026quot;:\u0026quot;image-20241029144743-kzvxkeu.png\u0026quot;,\u0026quot;hash\u0026quot;:\u0026quot;82991da00250d32cb9b46c1f389d74cc\u0026quot;,\u0026quot;originUrl\u0026quot;:\u0026quot;assets/image-20241029144743-kzvxkeu.png\u0026quot;,\u0026quot;url\u0026quot;:\u0026quot;https://syc-test111.oss-cn-chengdu.aliyuncs.com/20241029144743.png\u0026quot;,\u0026quot;alt\u0026quot;:\u0026quot;image.png\u0026quot;,\u0026quot;title\u0026quot;:\u0026quot;image.png\u0026quot;,\u0026quot;isLocal\u0026quot;:false,\u0026quot;blockId\u0026quot;:\u0026quot;\u0026quot;\u0026#125;,\u0026quot;4fbe1841fc15aca57adf0165d25c3858\u0026quot;:\u0026#123;\u0026quot;name\u0026quot;:\u0026quot;image-20241029172521-2r527bd.png\u0026quot;,\u0026quot;hash\u0026quot;:\u0026quot;4fbe1841fc15aca57adf0165d25c3858\u0026quot;,\u0026quot;originUrl\u0026quot;:\u0026quot;assets/image-20241029172521-2r527bd.png\u0026quot;,\u0026quot;url\u0026quot;:\u0026quot;https://syc-test111.oss-cn-chengdu.aliyuncs.com/image-20241029172521-2r527bd.png\u0026quot;,\u0026quot;alt\u0026quot;:\u0026quot;image\u0026quot;,\u0026quot;title\u0026quot;:\u0026quot;\u0026quot;,\u0026quot;isLocal\u0026quot;:false,\u0026quot;blockId\u0026quot;:\u0026quot;20241029172521-0a137i0\u0026quot;\u0026#125;,\u0026quot;89ce0d1990be3b1847cfb03e4c830c44\u0026quot;:\u0026#123;\u0026quot;name\u0026quot;:\u0026quot;image-20241101142831-g4v7mhq.png\u0026quot;,\u0026quot;hash\u0026quot;:\u0026quot;89ce0d1990be3b1847cfb03e4c830c44\u0026quot;,\u0026quot;originUrl\u0026quot;:\u0026quot;assets/image-20241101142831-g4v7mhq.png\u0026quot;,\u0026quot;url\u0026quot;:\u0026quot;https://syc-test111.oss-cn-chengdu.aliyuncs.com/image-20241101142831-g4v7mhq.png\u0026quot;,\u0026quot;alt\u0026quot;:\u0026quot;image\u0026quot;,\u0026quot;title\u0026quot;:\u0026quot;\u0026quot;,\u0026quot;isLocal\u0026quot;:false,\u0026quot;blockId\u0026quot;:\u0026quot;20241030002347-3jbx96c\u0026quot;\u0026#125;,\u0026quot;a2b540b70ae31b026a3a0caecbef9243\u0026quot;:\u0026#123;\u0026quot;name\u0026quot;:\u0026quot;image-20241121035146-8y5ezvo.png\u0026quot;,\u0026quot;hash\u0026quot;:\u0026quot;a2b540b70ae31b026a3a0caecbef9243\u0026quot;,\u0026quot;originUrl\u0026quot;:\u0026quot;assets/image-20241121035146-8y5ezvo.png\u0026quot;,\u0026quot;url\u0026quot;:\u0026quot;https://syc-test111.oss-cn-chengdu.aliyuncs.com/image-20241121035146-8y5ezvo.png\u0026quot;,\u0026quot;alt\u0026quot;:\u0026quot;image\u0026quot;,\u0026quot;title\u0026quot;:\u0026quot;\u0026quot;,\u0026quot;isLocal\u0026quot;:false,\u0026quot;blockId\u0026quot;:\u0026quot;20241121035146-8pq7rjm\u0026quot;\u0026#125;\u0026#125;","id":"20241029132024-gd8ejpm","tags":"面经","title":"JVM面经","type":"doc","updated":"20241121035923"},"Children":[{"ID":"20241029132356-7ldk1r1","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20241029132356-7ldk1r1","updated":"20241029144920"},"Children":[{"Type":"NodeText","Data":"内存管理"}]},{"ID":"20241029132024-o4ao0oo","Type":"NodeParagraph","Properties":{"id":"20241029132024-o4ao0oo","updated":"20241029132341"},"Children":[{"Type":"NodeText","Data":"JDK1.8："}]},{"ID":"20241029132343-ydbfoik","Type":"NodeParagraph","Properties":{"id":"20241029132343-ydbfoik","updated":"20241029132343"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20241029132343-yy8w6rb.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20241029132344-ft2i26t","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20241029132344-ft2i26t","updated":"20241029144920"},"Children":[{"Type":"NodeText","Data":"虚拟机栈+本地方法栈"}]},{"ID":"20241029144746-tbq12lt","Type":"NodeParagraph","Properties":{"id":"20241029144746-tbq12lt","updated":"20241029144757"},"Children":[{"Type":"NodeText","Data":"内容：类似其他语言"}]},{"ID":"20241029144743-u2xq4fg","Type":"NodeParagraph","Properties":{"id":"20241029144743-u2xq4fg","updated":"20241029144745"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"https://syc-test111.oss-cn-chengdu.aliyuncs.com/20241029144743.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20241029144920-zyl4hvy","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20241029144920-zyl4hvy","updated":"20241029152017"},"Children":[{"Type":"NodeText","Data":"堆"}]},{"ID":"20241029144932-9uxf7hc","Type":"NodeParagraph","Properties":{"id":"20241029144932-9uxf7hc","updated":"20241029145124"},"Children":[{"Type":"NodeText","Data":"线程共享的，里面装着所有的对象（现代编译器会进行一定的优化，一部分对象会直接放到栈里面）。"}]},{"ID":"20241029144959-8ji722l","Type":"NodeParagraph","Properties":{"id":"20241029144959-8ji722l","updated":"20241029145146"},"Children":[{"Type":"NodeText","Data":"Java 堆从 GC 的角度还可以细分为：新生代（Eden 区、SurvivorFrom 区和 SurvivorTo 区）和老年代。"}]},{"ID":"20241029145521-hslteok","Type":"NodeParagraph","Properties":{"id":"20241029145521-hslteok","updated":"20241029145521"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20241029145521-7x132nv.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20241029145521-mp36aqj","Type":"NodeParagraph","Properties":{"id":"20241029145521-mp36aqj","updated":"20241029151127"},"Children":[{"Type":"NodeText","Data":"S0即SF，S1即ST。对象都会首先在 Eden 区域分配，在一次"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"新生代垃圾回收（轻GC）"},{"Type":"NodeText","Data":"后，如果对象还存活，则会进入S0，并且对象的年龄还会加 1(Eden 区-\u003eSurvivor 区后对象的初始年龄变为 1)。"}]},{"ID":"20241029145611-p8dvdim","Type":"NodeParagraph","Properties":{"id":"20241029145611-p8dvdim","updated":"20241029150009"},"Children":[{"Type":"NodeText","Data":"每次新生代垃圾回收的过程是：复制 --\u003e 清空 --\u003e 互换"}]},{"ID":"20241029150010-nb37eeb","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20241029150010-nb37eeb","updated":"20241029150052"},"Children":[{"ID":"20241029150023-qypqvws","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20241029150023-qypqvws","updated":"20241029150023"},"Children":[{"ID":"20241029150023-gstzdcu","Type":"NodeParagraph","Properties":{"id":"20241029150023-gstzdcu","updated":"20241029150037"},"Children":[{"Type":"NodeText","Data":"eden、servicorFrom 复制到 ServicorTo，年龄+1（如果有对象的年龄以及达到了老年的标准，则赋值到老年代区）"}]}]},{"ID":"20241029150038-dgfc6hi","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20241029150038-dgfc6hi","updated":"20241029150038"},"Children":[{"ID":"20241029150038-0ci32hh","Type":"NodeParagraph","Properties":{"id":"20241029150038-0ci32hh","updated":"20241029150043"},"Children":[{"Type":"NodeText","Data":"清空 eden、servicorFrom"}]}]},{"ID":"20241029150044-98xw078","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20241029150044-98xw078","updated":"20241029150052"},"Children":[{"ID":"20241029150044-6jh0j3q","Type":"NodeParagraph","Properties":{"id":"20241029150044-6jh0j3q","updated":"20241029150052"},"Children":[{"Type":"NodeText","Data":"ServicorTo 和 ServicorFrom 互换，原 ServicorTo 成为下一次 GC 时的 ServicorFrom 区。"}]}]}]},{"ID":"20241029150052-jaadjph","Type":"NodeParagraph","Properties":{"id":"20241029150052-jaadjph","updated":"20241029151133"},"Children":[{"Type":"NodeText","Data":"老年的标准：是动态的，首先有一个MAX，默认是15。Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累加，当累加到某个年龄时，所累加的大小超过了 Survivor 区的一半，则取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值。"}]},{"ID":"20241029151914-eqxomr1","Type":"NodeParagraph","Properties":{"id":"20241029151914-eqxomr1","updated":"20241029152017"},"Children":[{"Type":"NodeText","Data":"堆里面还有"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"字符串常量池"},{"Type":"NodeText","Data":"，是直接写在代码里面的用引号包围的字符串常量，会随着其他对象一起被GC。"}]},{"ID":"20241029150246-1739794","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20241029150246-1739794","updated":"20241029151813"},"Children":[{"Type":"NodeText","Data":"方法区"}]},{"ID":"20241029150449-6cepywo","Type":"NodeParagraph","Properties":{"id":"20241029150449-6cepywo","updated":"20241029150856"},"Children":[{"Type":"NodeText","Data":"当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 "},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"类信息"},{"Type":"NodeText","Data":"、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据。"}]},{"ID":"20241029151430-3h7d5ni","Type":"NodeParagraph","Properties":{"id":"20241029151430-3h7d5ni","updated":"20241029151813"},"Children":[{"Type":"NodeText","Data":"这里还包括"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"运行时常量池"},{"Type":"NodeText","Data":"，可以理解为类的符号表，包含字面量和静态常量（例如指向字符串常量池某个特定指定对象的引用，数字等）。"}]},{"ID":"20241029150429-7ymjkoo","Type":"NodeParagraph","Properties":{"id":"20241029150429-7ymjkoo","updated":"20241029150657"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"永久代以及元空间"},{"Type":"NodeText","Data":"是 HotSpot 虚拟机对虚拟机规范中方法区的两种实现方式。永久代以及元空间的区别可以理解为一个在本地内存，一个在JVM内存。"}]},{"ID":"20241029150615-pqwzknp","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20241029150615-pqwzknp","updated":"20241029152657"},"Children":[{"Type":"NodeText","Data":"对象创建过程"}]},{"ID":"20241029152052-jcp7fq2","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20241029152052-jcp7fq2","updated":"20241029152657"},"Children":[{"ID":"20241029152118-x365gtq","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20241029152118-x365gtq","updated":"20241029152118"},"Children":[{"ID":"20241029152118-vkpcd9o","Type":"NodeParagraph","Properties":{"id":"20241029152118-vkpcd9o","updated":"20241029152119"},"Children":[{"Type":"NodeText","Data":"遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。"}]}]},{"ID":"20241029152119-411re22","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20241029152119-411re22","updated":"20241029152657"},"Children":[{"ID":"20241029152119-9ttkfrt","Type":"NodeParagraph","Properties":{"id":"20241029152119-9ttkfrt","updated":"20241029152657"},"Children":[{"Type":"NodeText","Data":"在类加载检查通过后，接下来虚拟机将为新生对象分配内存。同操作系统一样，可以让堆内存是有序的，那么新分配内存就只需要从最后面的指针处那一块内存就行，也可以让堆内存无序，那么就需要维护一个空闲列表。【此处利用乐观锁保证线程安全，具体是CAS】"}]}]},{"ID":"20241029152325-csmemgb","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20241029152325-csmemgb","updated":"20241029152325"},"Children":[{"ID":"20241029152325-1hrxer0","Type":"NodeParagraph","Properties":{"id":"20241029152325-1hrxer0","updated":"20241029152447"},"Children":[{"Type":"NodeText","Data":"内存空间都初始化为零值。"}]}]},{"ID":"20241029152445-wbyacd2","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"NC4=","Num":4},"Properties":{"id":"20241029152445-wbyacd2","updated":"20241029152445"},"Children":[{"ID":"20241029152445-2ioqeyr","Type":"NodeParagraph","Properties":{"id":"20241029152445-2ioqeyr","updated":"20241029152509"},"Children":[{"Type":"NodeText","Data":"设置对象头，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。"}]}]},{"ID":"20241029152511-ch5jarz","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"NS4=","Num":5},"Properties":{"id":"20241029152511-ch5jarz","updated":"20241029152511"},"Children":[{"ID":"20241029152511-zzb417l","Type":"NodeParagraph","Properties":{"id":"20241029152511-zzb417l","updated":"20241029152529"},"Children":[{"Type":"NodeText","Data":"执行构造方法。"}]}]}]},{"ID":"20241029152606-6xfk08r","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20241029152606-6xfk08r","updated":"20241029153334"},"Children":[{"Type":"NodeText","Data":"对象访问过程"}]},{"ID":"20241029152322-8cgn4uu","Type":"NodeParagraph","Properties":{"id":"20241029152322-8cgn4uu","updated":"20241029153244"},"Children":[{"Type":"NodeText","Data":"建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定。"}]},{"ID":"20241029153322-ey0u56d","Type":"NodeParagraph","Properties":{"id":"20241029153322-ey0u56d","updated":"20241029153329"},"Children":[{"Type":"NodeText","Data":"目前主流的访问方式有："},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"使用句柄"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"直接指针"},{"Type":"NodeText","Data":"。"}]},{"ID":"20241029153305-qg6j8nv","Type":"NodeParagraph","Properties":{"id":"20241029153305-qg6j8nv","updated":"20241029153305"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20241029153305-zfjqbsw.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20241029153318-82jhkdk","Type":"NodeParagraph","Properties":{"id":"20241029153318-82jhkdk","updated":"20241029153318"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20241029153318-c6m84rt.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20241029153330-46x499j","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20241029153330-46x499j","updated":"20241030001838"},"Children":[{"Type":"NodeText","Data":"垃圾回收"}]},{"ID":"20241030001827-30wa4pt","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20241030001827-30wa4pt","updated":"20241030001838"},"Children":[{"Type":"NodeText","Data":"哪些要回收？何时回收？"}]},{"ID":"20241029153344-qdot3ea","Type":"NodeParagraph","Properties":{"id":"20241029153344-qdot3ea","updated":"20241029154543"},"Children":[{"Type":"NodeText","Data":"何时进行垃圾回收？"}]},{"ID":"20241029154548-09m1zo0","Type":"NodeParagraph","Properties":{"id":"20241029154548-09m1zo0","updated":"20241029155610"},"Children":[{"Type":"NodeText","Data":"分两种：轻GC（只GC新生区）、重GC（GC整个堆）。"}]},{"ID":"20241029155614-8n0u8at","Type":"NodeParagraph","Properties":{"id":"20241029155614-8n0u8at","updated":"20241029155914"},"Children":[{"Type":"NodeText","Data":"哪些对象需要回收？"}]},{"ID":"20241029155915-47a9u6m","Type":"NodeParagraph","Properties":{"id":"20241029155915-47a9u6m","updated":"20241029161309"},"Children":[{"Type":"NodeText","Data":"利用可达性分析，分析一个对象到GCRoots是不是可达的，如果不可达就是可回收的。老Java在回收前还会处理finalize方法，现在正在逐步废弃。"}]},{"ID":"20241030001108-v83sih5","Type":"NodeParagraph","Properties":{"id":"20241030001108-v83sih5","updated":"20241030001141"},"Children":[{"Type":"NodeText","Data":"GCRoots是指："}]},{"ID":"20241030001149-00md7b5","Type":"NodeParagraph","Properties":{"id":"20241030001149-00md7b5","updated":"20241030001238"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Java 虚拟机栈（栈帧中的本地变量表）中引用的对象"},{"Type":"NodeText","Data":"、本地方法栈中引用的对象、方法区中常量引用的对象、方法区中类静态属性引用的对象。"}]},{"ID":"20241030001239-grsb1gz","Type":"NodeParagraph","Properties":{"id":"20241030001239-grsb1gz","updated":"20241030001255"},"Children":[{"Type":"NodeText","Data":"而在第一点上，Java有一些独特的操作："}]},{"ID":"20241030001255-795yiby","Type":"NodeParagraph","Properties":{"id":"20241030001255-795yiby","updated":"20241030001305"},"Children":[{"Type":"NodeText","Data":"Java对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4种，这4种引用强度依次逐渐减弱。"}]},{"ID":"20241030001307-mnr5pjc","Type":"NodeParagraph","Properties":{"id":"20241030001307-mnr5pjc","updated":"20241030001636"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"强引用"},{"Type":"NodeText","Data":"就是我们平时说的引用。而"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"软引用"},{"Type":"NodeText","Data":"是一般不GC，在JVM内存不够时才GC。"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"弱引用"},{"Type":"NodeText","Data":"就是GC时就会回收的引用，不管内存充不充足。"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"虚引用"},{"Type":"NodeText","Data":"也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。无法通过虚引用来取得一个对象实例，设置虚引用的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。"}]},{"ID":"20241029161309-af4ux76","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20241029161309-af4ux76","updated":"20241113134617"},"Children":[{"Type":"NodeText","Data":"垃圾收集算法（垃圾清除到底怎么做？）"}]},{"ID":"20241030001647-o06cfdl","Type":"NodeParagraph","Properties":{"id":"20241030001647-o06cfdl","updated":"20241030001856"},"Children":[{"Type":"NodeText","Data":"首先有三种具体操作方案：标记-清除（Mark-Sweep）算法、复制（Copying）算法、标记-整理（Mark-Compact）算法。"}]},{"ID":"20241029163348-y26f6z1","Type":"NodeParagraph","Properties":{"id":"20241029163348-y26f6z1","updated":"20241029163348"},"Children":[{"Type":"NodeText","Data":"当一个对象被创建时，给一个标记位，假设为 0 (false)；在标记阶段，我们将所有可达对象（或用户可以引用的对象）的标记位设置为 1 (true)；扫描阶段清除的就是标记位为 0 (false)的对象。"}]},{"ID":"20241029163739-fnf8x5n","Type":"NodeParagraph","Properties":{"id":"20241029163739-fnf8x5n","updated":"20241029163739"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20241029163739-1gg0yp3.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20241030001907-2key3k4","Type":"NodeParagraph","Properties":{"id":"20241030001907-2key3k4","updated":"20241030001907"},"Children":[{"Type":"NodeText","Data":"但是这样会产生大量的内存碎片，因此第二种："}]},{"ID":"20241029172521-0a137i0","Type":"NodeParagraph","Properties":{"id":"20241029172521-0a137i0","updated":"20241113134617"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"https://syc-test111.oss-cn-chengdu.aliyuncs.com/image-20241029172521-2r527bd.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20241029172522-779n9rn","Type":"NodeParagraph","Properties":{"id":"20241029172522-779n9rn","updated":"20241029172528"},"Children":[{"Type":"NodeText","Data":"由于多了整理这一步，因此效率也不高，适合老年代这种垃圾回收频率不是很高的场景。"}]},{"ID":"20241030001935-59r1q38","Type":"NodeParagraph","Properties":{"id":"20241030001935-59r1q38","updated":"20241030002110"},"Children":[{"Type":"NodeText","Data":"因此第三种：复制方式，如图所示，问题就是会浪费一半的空间。但实际上，新生代中的对象98%是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间。将堆内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。"}]},{"ID":"20241030001926-3m55qcv","Type":"NodeParagraph","Properties":{"id":"20241030001926-3m55qcv","updated":"20241030001926"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20241030001926-8m5ogui.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20241029172528-p2k6w8w","Type":"NodeParagraph","Properties":{"id":"20241029172528-p2k6w8w","updated":"20241029172719"},"Children":[{"Type":"NodeText","Data":"而现代VM都会采用分代收集，采用不同的策略回收不同代的垃圾。"}]},{"ID":"20241029172720-p4zaken","Type":"NodeParagraph","Properties":{"id":"20241029172720-p4zaken","updated":"20241030002229"},"Children":[{"Type":"NodeText","Data":"大流程："}]},{"ID":"20241030002230-2mzxlty","Type":"NodeParagraph","Properties":{"id":"20241030002230-2mzxlty","updated":"20241030002230"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20241030002230-nsh567p.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20241030002238-07sf504","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20241030002238-07sf504","updated":"20241113134635"},"Children":[{"Type":"NodeText","Data":"具体GC的操作"}]},{"ID":"20241030002350-c7wjwo8","Type":"NodeParagraph","Properties":{"id":"20241030002350-c7wjwo8","updated":"20241030002359"},"Children":[{"Type":"NodeText","Data":"GC有哪些呢？有这些："}]},{"ID":"20241030002347-3jbx96c","Type":"NodeParagraph","Properties":{"id":"20241030002347-3jbx96c","updated":"20241113134635"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"https://syc-test111.oss-cn-chengdu.aliyuncs.com/image-20241030002347-r3ic106.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20241030002401-jn1qym0","Type":"NodeList","ListData":{},"Properties":{"id":"20241030002401-jn1qym0","updated":"20241030002615"},"Children":[{"ID":"20241030002615-kors2wi","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20241030002615-kors2wi","updated":"20241030002615"},"Children":[{"ID":"20241030002615-blojxv5","Type":"NodeParagraph","Properties":{"id":"20241030002615-blojxv5","updated":"20241030002615"},"Children":[{"Type":"NodeText","Data":"最简单的Serial：单线程回收，它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束（STW阶段）。而Serial Old几乎是一样的，不过是把复制算法改成标志-整理。"}]}]}]},{"ID":"20241030002613-o3h4v74","Type":"NodeList","ListData":{},"Properties":{"id":"20241030002613-o3h4v74","updated":"20241101134241"},"Children":[{"ID":"20241030002623-od42e7i","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20241030002623-od42e7i","updated":"20241030002623"},"Children":[{"ID":"20241030002623-2g2y61i","Type":"NodeParagraph","Properties":{"id":"20241030002623-2g2y61i","updated":"20241030003113"},"Children":[{"Type":"NodeText","Data":"Parallel并行：核心是多线程，可以利用多CPU。ParNew就是这样。但它引申出了Parallel Scavenge：可以调整垃圾回收强度，减少每次垃圾回收的时间。Parallel Old就是老年代版本。"}]}]},{"ID":"20241030003114-h689662","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20241030003114-h689662","updated":"20241030003114"},"Children":[{"ID":"20241030003114-b7lgkyd","Type":"NodeParagraph","Properties":{"id":"20241030003114-b7lgkyd","updated":"20241030003256"},"Children":[{"Type":"NodeText","Data":"CMS：并发标记清除，核心是使得清除过程中一部分工作的可以和用户线程并行，减少停顿。这东西分四步："}]},{"ID":"20241030003306-qpxwzdq","Type":"NodeList","ListData":{},"Properties":{"id":"20241030003306-qpxwzdq","updated":"20241030003306"},"Children":[{"ID":"20241030003306-e8kk3m7","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20241030003306-e8kk3m7","updated":"20241030003306"},"Children":[{"ID":"20241030003306-9v3uvmj","Type":"NodeParagraph","Properties":{"id":"20241030003306-9v3uvmj","updated":"20241030003336"},"Children":[{"Type":"NodeText","Data":"初始标记：标记Root的下级（仅下一级），会很快，会导致停顿。"}]}]},{"ID":"20241030003336-z3ykfmw","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20241030003336-z3ykfmw","updated":"20241030003336"},"Children":[{"ID":"20241030003336-myzq3j0","Type":"NodeParagraph","Properties":{"id":"20241030003336-myzq3j0","updated":"20241030003427"},"Children":[{"Type":"NodeText","Data":"并发标记：从第二级开始接着往下标记，但这个过程与用户线程并行。"}]}]},{"ID":"20241030003428-kcadfx3","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20241030003428-kcadfx3","updated":"20241030003428"},"Children":[{"ID":"20241030003428-t2n8ygu","Type":"NodeParagraph","Properties":{"id":"20241030003428-t2n8ygu","updated":"20241030003724"},"Children":[{"Type":"NodeText","Data":"重新标记：第 2 步并没有阻塞其它工作线程，在第2步过程中很有可能会产生新的垃圾，但花费时间也相对较少，因为新垃圾肯定不多。"}]}]},{"ID":"20241030003727-blr0v6p","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20241030003727-blr0v6p","updated":"20241030003727"},"Children":[{"ID":"20241030003727-gwnz4fg","Type":"NodeParagraph","Properties":{"id":"20241030003727-gwnz4fg","updated":"20241030003743"},"Children":[{"Type":"NodeText","Data":"并行清除：再并行地清除。"}]}]}]}]},{"ID":"20241030003744-gj4kjll","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20241030003744-gj4kjll","updated":"20241101134241"},"Children":[{"ID":"20241030003744-uzd9qb0","Type":"NodeParagraph","Properties":{"id":"20241030003744-uzd9qb0","updated":"20241101134241"},"Children":[{"Type":"NodeText","Data":"G1：设计很不一样"}]}]}]},{"ID":"20241101134105-5gx0qx8","Type":"NodeBlockquote","Properties":{"id":"20241101134105-5gx0qx8","updated":"20241101154625"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20241101134112-4trmrie","Type":"NodeParagraph","Properties":{"id":"20241101134112-4trmrie","updated":"20241101134130"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"G1详解"}]},{"ID":"20241101134132-377yjpv","Type":"NodeParagraph","Properties":{"id":"20241101134132-377yjpv","updated":"20241101151043"},"Children":[{"Type":"NodeText","Data":"在G1中，region是不连续的，每个对象占用region一部分，而不同代是混杂的。"}]},{"ID":"20241101134249-c2vx0dw","Type":"NodeParagraph","Properties":{"id":"20241101134249-c2vx0dw","updated":"20241101134249"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20241101134249-cnxp7yg.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20241101134251-e9td22v","Type":"NodeParagraph","Properties":{"id":"20241101134251-e9td22v","updated":"20241101134419"},"Children":[{"Type":"NodeText","Data":"这里的H是什么呢，是指大对象，大小超过Region一半的对象会直接放进老年代，避免频繁GC。"}]},{"ID":"20241101153242-j7ki23p","Type":"NodeParagraph","Properties":{"id":"20241101153242-j7ki23p","updated":"20241101154625"},"Children":[{"Type":"NodeText","Data":"从大类上分，G1有两种回收模式：完全年轻化GC、部分年轻化GC。"}]}]},{"ID":"20241101142041-6snngc1","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20241101142041-6snngc1","updated":"20241101143820"},"Children":[{"Type":"NodeText","Data":"技术细节"}]},{"ID":"20241101141940-hop1tjj","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20241101141940-hop1tjj","updated":"20241101143820"},"Children":[{"ID":"20241101142059-7wffmpz","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20241101142059-7wffmpz","updated":"20241101143820"},"Children":[{"ID":"20241101142059-qxve5xe","Type":"NodeParagraph","Properties":{"id":"20241101142059-qxve5xe","updated":"20241101143820"},"Children":[{"Type":"NodeText","Data":"RememberSet（CMS和G1使用）"}]}]}]},{"ID":"20241101142101-e6lsir8","Type":"NodeParagraph","Properties":{"id":"20241101142101-e6lsir8","updated":"20241101142546"},"Children":[{"Type":"NodeText","Data":"很多时候会存在跨区域引用的情况，比如某个新生代对象没有被任何新生代对象引用，但对老年代对象引用，那么做部分GC的时候为了确切的区分出到底是不是可以安全GC的对象，实际上就要遍历全部对象，显然效率很低。"}]},{"ID":"20241101142824-aa2tzss","Type":"NodeParagraph","Properties":{"id":"20241101142824-aa2tzss","updated":"20241101142824"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20241101142824-ta3hi8p.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20241101142547-1g9bfpc","Type":"NodeParagraph","Properties":{"id":"20241101142547-1g9bfpc","updated":"20241101142635"},"Children":[{"Type":"NodeText","Data":"于是就有了RememberSet（RS or RSet）。"}]},{"ID":"20241101142831-vzgo18x","Type":"NodeParagraph","Properties":{"id":"20241101142831-vzgo18x","updated":"20241101142831"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20241101142831-g4v7mhq.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20241101142837-qdskjd1","Type":"NodeParagraph","Properties":{"id":"20241101142837-qdskjd1","updated":"20241101142910"},"Children":[{"Type":"NodeText","Data":"在对象晋升的时候，将晋升对象记录下来，这个存储跨区引用关系的容器称之为RSet。利用一个RSet来记录这个跨区域引用的关系，每个区域都有一个RSet，这样在进行标记的时候，将RSet也作为ROOTS进行遍历即可。"}]},{"ID":"20241101142839-pd0hk5j","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20241101142839-pd0hk5j","updated":"20241121035923"},"Children":[{"Type":"NodeText","Data":"类加载"}]},{"ID":"20241121035137-jx15483","Type":"NodeParagraph","Properties":{"id":"20241121035137-jx15483","updated":"20241121035140"},"Children":[{"Type":"NodeText","Data":"类从被加载到虚拟机内存中开始到卸载出内存为止，它的整个生命周期可以简单概括为 7 个阶段：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）。其中，验证、准备和解析这三个阶段可以统称为连接（Linking）。"}]},{"ID":"20241121035146-8pq7rjm","Type":"NodeParagraph","Properties":{"id":"20241121035146-8pq7rjm","updated":"20241121035923"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Properties":{"style":"width: 421px;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"https://syc-test111.oss-cn-chengdu.aliyuncs.com/image-20241121035146-8y5ezvo.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"width: 421px;\"}"},{"Type":"NodeText","Data":"​"}]},{"ID":"20241121035147-8vu4iqh","Type":"NodeParagraph","Properties":{"id":"20241121035147-8vu4iqh","updated":"20241121035622"},"Children":[{"Type":"NodeText","Data":"在其中，"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"加载-\u0026gt;连接-\u0026gt;初始化"},{"Type":"NodeText","Data":"是类加载过程"}]}]}