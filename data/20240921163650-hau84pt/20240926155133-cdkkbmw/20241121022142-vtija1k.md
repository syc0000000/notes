# MySQL索引失效常见原因分析

## 索引失效

根据[文章](https://mp.weixin.qq.com/s/mwME3qukHBFul57WQLkOYg)

索引失效场景总结：

1. **最左匹配原则失效**：在使用联合索引时，如果查询条件没有遵循索引的最左前缀规则，即没有从索引的最左边列开始匹配，索引将不会生效。
2. **使用函数或计算导致索引失效**：对索引列使用函数或进行计算操作时，索引将失效，因为索引存储的是列的原始值。
3. **类型不匹配导致索引失效**：如果查询条件中的数据类型与索引列的类型不一致，可能会导致索引失效。
4. **使用了不等式操作导致索引失效**：使用\<、\>等不等式操作符时，可能会导致索引失效，尤其是当它们出现在查询的最前面时。
5. **使用了OR导致索引失效**：在查询条件中使用了OR，且OR前后的字段不是同一个索引的列时，可能会导致索引失效。
6. **使用了IS NULL导致索引失效**：对索引列使用IS NULL条件时，可能会导致索引失效。
7. **使用了IN导致索引失效**：当IN子句中的值较多时，可能会导致索引失效，因为MySQL可能认为全表扫描比使用索引更快。
8. **使用了LIKE '%...'导致索引失效**：使用LIKE进行模糊查询时，如果模式以百分号开头，索引将失效。
9. **使用了NOT IN导致索引失效**：使用NOT IN时，可能会导致索引失效，因为MySQL可能认为全表扫描比使用索引更快。
10. **使用了NOT EXISTS导致索引失效**：使用NOT EXISTS时，可能会导致索引失效，因为MySQL可能认为全表扫描比使用索引更快。
11. **强制类型转换导致索引失效**：查询条件中的数据类型与索引列的数据类型不一致，导致MySQL进行强制类型转换，从而使索引失效。
12. **使用了ORDER BY和GROUP BY导致索引失效**：在排序和分组操作中，MySQL可能认为全表扫描比回表排序更快，导致索引失效。
13. **使用了子查询导致索引失效**：在某些情况下，子查询可能不使用外部查询的索引。
14. **使用了不等式和等式混合条件导致索引失效**：在查询条件中混合使用不等式和等式条件时，可能会导致索引失效。

## 联合索引最左匹配

最左前缀匹配原则指的是在使用联合索引时，MySQL 会根据索引中的字段顺序，从左到右依次匹配查询条件中的字段。如果查询条件与索引中的最左侧字段相匹配，那么 MySQL 就会使用索引来过滤数据，这样可以提高查询效率。

假设有一个联合索引`(column1, column2, column3)`​，其从左到右的所有前缀为`(column1)`​、`(column1, column2)`​、`(column1, column2, column3)`（创建 1 个联合索引相当于创建了 3 个索引），包含这些列的所有查询都会走索引而不会全表扫描。

如果有索引 `联合索引（a，b，c）`​，查询 `a=1 AND c=1`​会走索引么？`c=1`​ 呢？`b=1 AND c=1`呢？

1. 查询 `a=1 AND c=1`​：根据最左前缀匹配原则，查询可以使用索引的前缀部分。因此，该查询仅在 `a=1`​ 上使用索引，然后对结果进行 `c=1` 的过滤。
2. 查询 `c=1`​ ：由于查询中不包含最左列 `a`，根据最左前缀匹配原则，整个索引都无法被使用。
3. 查询`b=1 AND c=1`：和第二种一样的情况，整个索引都不会使用。

## 回表查询与索引下推

‍
