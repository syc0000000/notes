{"ID":"20240926155204-1yzx18p","Spec":"1","Type":"NodeDocument","Properties":{"custom-common-Halo-yaml":"---_esc_newline_created: '2024-09-26 15:52:04'_esc_newline_updated: '2024-09-26 23:20:35'_esc_newline_title: SpringBoot面经——SpringBean部分_esc_newline_slug: springboot-facial-sutra-springbean-part-z29lvll_esc_newline_permalink: siyuan://blocks/20240926155204-1yzx18p_esc_newline_tags:_esc_newline_  - Java_esc_newline_  - 面经_esc_newline_categories: []_esc_newline_---","custom-picgo-file-map-key":"\u0026#123;\u0026quot;44c96ddd258a2c5f5d1ff7d6f9316903\u0026quot;:\u0026#123;\u0026quot;name\u0026quot;:\u0026quot;image-20240926155955-y1fs8og.png\u0026quot;,\u0026quot;hash\u0026quot;:\u0026quot;44c96ddd258a2c5f5d1ff7d6f9316903\u0026quot;,\u0026quot;originUrl\u0026quot;:\u0026quot;assets/image-20240926155955-y1fs8og.png\u0026quot;,\u0026quot;url\u0026quot;:\u0026quot;https://syc-test111.oss-cn-chengdu.aliyuncs.com/image-20240926155955-y1fs8og.png\u0026quot;,\u0026quot;alt\u0026quot;:\u0026quot;image\u0026quot;,\u0026quot;title\u0026quot;:\u0026quot;\u0026quot;,\u0026quot;isLocal\u0026quot;:false,\u0026quot;blockId\u0026quot;:\u0026quot;20240926155955-0dpwo2u\u0026quot;\u0026#125;\u0026#125;","id":"20240926155204-1yzx18p","tags":"Java,面经","title":"SpringBoot面经——SpringBean部分","type":"doc","updated":"20241010190820"},"Children":[{"ID":"20240926155204-0971wza","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240926155204-0971wza","updated":"20240926232040"},"Children":[{"Type":"NodeText","Data":"Spring组成"}]},{"ID":"20240926155955-0dpwo2u","Type":"NodeParagraph","Properties":{"id":"20240926155955-0dpwo2u","updated":"20240926232040"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"https://syc-test111.oss-cn-chengdu.aliyuncs.com/image-20240926155955-y1fs8og.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20240926160158-s2fmlsd","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240926160158-s2fmlsd","updated":"20240926160401"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Core Container"}]},{"ID":"20240926160312-0iw1nfc","Type":"NodeParagraph","Properties":{"id":"20240926160312-0iw1nfc","updated":"20240926160312"},"Children":[{"Type":"NodeText","Data":"Spring 框架的核心模块，也可以说是基础模块，主要提供 IoC 依赖注入功能的支持。"}]},{"ID":"20240926160315-xmzuthm","Type":"NodeParagraph","Properties":{"id":"20240926160315-xmzuthm","updated":"20240926160315"},"Children":[{"Type":"NodeText","Data":"Spring 其他所有的功能基本都需要依赖于该模块，我们从上面那张 Spring 各个模块的依赖关系图就可以看出来。"}]},{"ID":"20240926160401-73vyy0q","Type":"NodeList","ListData":{},"Properties":{"id":"20240926160401-73vyy0q","updated":"20240926160401"},"Children":[{"ID":"20240926160401-uvacfn8","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240926160401-uvacfn8","style":"color: var(--b3-font-color1);","updated":"20240926160401"},"Children":[{"ID":"20240926160316-i62dnuc","Type":"NodeParagraph","Properties":{"id":"20240926160316-i62dnuc","updated":"20240926160316"},"Children":[{"Type":"NodeText","Data":"spring-core：Spring 框架基本的核心工具类。"}]}]},{"ID":"20240926160401-v0ly0ga","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240926160401-v0ly0ga","style":"color: var(--b3-font-color1);","updated":"20240926160401"},"Children":[{"ID":"20240926160316-2foke65","Type":"NodeParagraph","Properties":{"id":"20240926160316-2foke65","updated":"20240926160316"},"Children":[{"Type":"NodeText","Data":"spring-beans：提供对 bean 的创建、配置和管理等功能的支持。"}]}]},{"ID":"20240926160401-dt1jm8p","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240926160401-dt1jm8p","style":"color: var(--b3-font-color1);","updated":"20240926160401"},"Children":[{"ID":"20240926160317-dxpeq7u","Type":"NodeParagraph","Properties":{"id":"20240926160317-dxpeq7u","updated":"20240926160317"},"Children":[{"Type":"NodeText","Data":"spring-context：提供对国际化、事件传播、资源加载等功能的支持。"}]}]},{"ID":"20240926160401-dfqj08h","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240926160401-dfqj08h","style":"color: var(--b3-font-color1);","updated":"20240926160401"},"Children":[{"ID":"20240926160318-9vo7owp","Type":"NodeParagraph","Properties":{"id":"20240926160318-9vo7owp","updated":"20240926160318"},"Children":[{"Type":"NodeText","Data":"spring-expression：提供对表达式语言（Spring Expression Language） SpEL 的支持，只依赖于 core 模块，不依赖于其他模块，可以单独使用。"}]}]}]},{"ID":"20240926160318-wk5l65v","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240926160318-wk5l65v","updated":"20240926160421"},"Children":[{"Type":"NodeText","Data":"AOP"}]},{"ID":"20240926160420-aee8z1v","Type":"NodeList","ListData":{},"Properties":{"id":"20240926160420-aee8z1v","updated":"20240926160421"},"Children":[{"ID":"20240926160420-9w4slav","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240926160420-9w4slav","updated":"20240926160421"},"Children":[{"ID":"20240926160319-10gex2c","Type":"NodeParagraph","Properties":{"id":"20240926160319-10gex2c","updated":"20240926160421"},"Children":[{"Type":"NodeText","Data":"spring-aspects：该模块为与 AspectJ 的集成提供支持。"}]}]},{"ID":"20240926160420-y0ef4tw","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240926160420-y0ef4tw","updated":"20240926160421"},"Children":[{"ID":"20240926160319-g3kz50n","Type":"NodeParagraph","Properties":{"id":"20240926160319-g3kz50n","updated":"20240926160421"},"Children":[{"Type":"NodeText","Data":"spring-aop：提供了面向切面的编程实现。"}]}]},{"ID":"20240926160420-0vd9xb5","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240926160420-0vd9xb5","updated":"20240926160421"},"Children":[{"ID":"20240926160320-t1w1bsp","Type":"NodeParagraph","Properties":{"id":"20240926160320-t1w1bsp","updated":"20240926160421"},"Children":[{"Type":"NodeText","Data":"spring-instrument：提供了为 JVM 添加代理（agent）的功能。 具体来讲，它为 Tomcat 提供了一个织入代理，能够为 Tomcat 传递类文 件，就像这些文件是被类加载器加载的一样。没有理解也没关系，这个模块的使用场景非常有限。"}]}]}]},{"ID":"20240926160325-8rw91js","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240926160325-8rw91js","updated":"20240926160436"},"Children":[{"Type":"NodeText","Data":"Data Access/Integration"}]},{"ID":"20240926160432-664mz3l","Type":"NodeList","ListData":{},"Properties":{"id":"20240926160432-664mz3l","updated":"20240926160433"},"Children":[{"ID":"20240926160432-77836zt","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240926160432-77836zt","updated":"20240926160433"},"Children":[{"ID":"20240926160326-l4w7v51","Type":"NodeParagraph","Properties":{"id":"20240926160326-l4w7v51","updated":"20240926160433"},"Children":[{"Type":"NodeText","Data":"spring-jdbc：提供了对数据库访问的抽象 JDBC。不同的数据库都有自己独立的 API 用于操作数据库，而 Java 程序只需要和 JDBC API 交互，这样就屏蔽了数据库的影响。"}]}]},{"ID":"20240926160432-1eiphlw","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240926160432-1eiphlw","updated":"20240926160433"},"Children":[{"ID":"20240926160327-slb2a9c","Type":"NodeParagraph","Properties":{"id":"20240926160327-slb2a9c","updated":"20240926160433"},"Children":[{"Type":"NodeText","Data":"spring-tx：提供对事务的支持。"}]}]},{"ID":"20240926160432-fso35ou","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240926160432-fso35ou","updated":"20240926160433"},"Children":[{"ID":"20240926160328-80pfyzh","Type":"NodeParagraph","Properties":{"id":"20240926160328-80pfyzh","updated":"20240926160433"},"Children":[{"Type":"NodeText","Data":"spring-orm：提供对 Hibernate、JPA、iBatis 等 ORM 框架的支持。"}]}]},{"ID":"20240926160432-dgtiplm","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240926160432-dgtiplm","updated":"20240926160433"},"Children":[{"ID":"20240926160328-m6p18c4","Type":"NodeParagraph","Properties":{"id":"20240926160328-m6p18c4","updated":"20240926160433"},"Children":[{"Type":"NodeText","Data":"spring-oxm：提供一个抽象层支撑 OXM(Object-to-XML-Mapping)，例如：JAXB、Castor、XMLBeans、JiBX 和 XStream 等。"}]}]},{"ID":"20240926160432-htkivob","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240926160432-htkivob","updated":"20240926160433"},"Children":[{"ID":"20240926160329-bid6egt","Type":"NodeParagraph","Properties":{"id":"20240926160329-bid6egt","updated":"20240926160433"},"Children":[{"Type":"NodeText","Data":"spring-jms : 消息服务。自 Spring Framework 4.1 以后，它还提供了对 spring-messaging 模块的继承。"}]}]}]},{"ID":"20240926160330-0dgbgse","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240926160330-0dgbgse","updated":"20240926160507"},"Children":[{"Type":"NodeText","Data":"Spring Web"}]},{"ID":"20240926160506-6zsuemc","Type":"NodeList","ListData":{},"Properties":{"id":"20240926160506-6zsuemc","updated":"20240926160507"},"Children":[{"ID":"20240926160506-nvnd2tw","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240926160506-nvnd2tw","updated":"20240926160507"},"Children":[{"ID":"20240926160330-k7kda9f","Type":"NodeParagraph","Properties":{"id":"20240926160330-k7kda9f","updated":"20240926160507"},"Children":[{"Type":"NodeText","Data":"spring-web：对 Web 功能的实现提供一些最基础的支持。"}]}]},{"ID":"20240926160506-yb2kkv5","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240926160506-yb2kkv5","updated":"20240926160507"},"Children":[{"ID":"20240926160332-8r4nh7t","Type":"NodeParagraph","Properties":{"id":"20240926160332-8r4nh7t","updated":"20240926160507"},"Children":[{"Type":"NodeText","Data":"spring-webmvc：提供对 Spring MVC 的实现。"}]}]},{"ID":"20240926160506-6f5s76w","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240926160506-6f5s76w","updated":"20240926160507"},"Children":[{"ID":"20240926160332-63pb32t","Type":"NodeParagraph","Properties":{"id":"20240926160332-63pb32t","updated":"20240926160507"},"Children":[{"Type":"NodeText","Data":"spring-websocket：提供了对 WebSocket 的支持，WebSocket 可以让客户端和服务端进行双向通信。"}]}]},{"ID":"20240926160506-463925d","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240926160506-463925d","updated":"20240926160507"},"Children":[{"ID":"20240926160333-et67re6","Type":"NodeParagraph","Properties":{"id":"20240926160333-et67re6","updated":"20240926160507"},"Children":[{"Type":"NodeText","Data":"spring-webflux：提供对 WebFlux 的支持。WebFlux 是 Spring Framework 5.0 中引入的新的响应式框架。与 Spring MVC 不同，它不需要 Servlet API，是完全异步。"}]}]}]},{"ID":"20240926160335-wykkwte","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240926160335-wykkwte","updated":"20240926160456"},"Children":[{"Type":"NodeText","Data":"Messaging"}]},{"ID":"20240926160336-ufvk9o0","Type":"NodeParagraph","Properties":{"id":"20240926160336-ufvk9o0","updated":"20240926160336"},"Children":[{"Type":"NodeText","Data":"spring-messaging 是从 Spring4.0 开始新加入的一个模块，主要职责是为 Spring 框架集成一些基础的报文传送应用。"}]},{"ID":"20240926160337-j0zfa1a","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240926160337-j0zfa1a","updated":"20240926160532"},"Children":[{"Type":"NodeText","Data":"Spring Test"}]},{"ID":"20240926160337-2pqvol0","Type":"NodeParagraph","Properties":{"id":"20240926160337-2pqvol0","updated":"20240926160337"},"Children":[{"Type":"NodeText","Data":"Spring 团队提倡测试驱动开发（TDD）。有了控制反转 (IoC)的帮助，单元测试和集成测试变得更简单。"}]},{"ID":"20240926160338-tv8sjp1","Type":"NodeParagraph","Properties":{"id":"20240926160338-tv8sjp1","updated":"20240926160338"},"Children":[{"Type":"NodeText","Data":"Spring 的测试模块对 JUnit（单元测试框架）、TestNG（类似 JUnit）、Mockito（主要用来 Mock 对象）、PowerMock（解决 Mockito 的问题比如无法模拟 final, static， private 方法）等等常用的测试框架支持的都比较好。"}]},{"ID":"20240926160532-s1nyxs8","Type":"NodeHeading","HeadingLevel":2,"Properties":{"custom-plugin-incremental-reading":"true","id":"20240926160532-s1nyxs8","updated":"20240926181049"},"Children":[{"Type":"NodeText","Data":"SpringMVC到底是啥？"}]},{"ID":"20240926160649-ysu0jqg","Type":"NodeParagraph","Properties":{"id":"20240926160649-ysu0jqg","updated":"20240926160723"},"Children":[{"Type":"NodeText","Data":"使用 Spring 进行开发各种配置过于麻烦比如开启某些 Spring 特性时，需要用 XML 或 Java 进行显式配置。于是，Spring Boot 诞生了！"}]},{"ID":"20240926160725-ukwwh16","Type":"NodeParagraph","Properties":{"id":"20240926160725-ukwwh16","updated":"20240926160725"},"Children":[{"Type":"NodeText","Data":"Spring Boot 只是简化了配置，如果你需要构建 MVC 架构的 Web 程序，你还是需要使用 Spring MVC 作为 MVC 框架，只是说 Spring Boot 帮你简化了 Spring MVC 的很多配置，真正做到开箱即用！"}]},{"ID":"20240926160725-cdf2bcj","Type":"NodeParagraph","Properties":{"id":"20240926160725-cdf2bcj","updated":"20240926161313"},"Children":[{"Type":"NodeText","Data":"而SpringMVC是Spring MVC 是 Spring 中的一个很重要的模块，主要赋予 Spring 快速构建 MVC 架构的 Web 程序的能力。MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。"}]},{"ID":"20240926161320-eejg2m6","Type":"NodeParagraph","Properties":{"id":"20240926161320-eejg2m6","updated":"20240926161456"},"Children":[{"Type":"NodeText","Data":"当然，我们Web开发常用的注解基本都来自SpringMVC模块，但MVC模块中的Jsp模板相关内容其实很少使用了现在。一般都使用这个模块提供的Restful相关接口来做前后端分离的设计。"}]},{"ID":"20240926161556-xc8hhb8","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240926161556-xc8hhb8","updated":"20240926180148"},"Children":[{"Type":"NodeText","Data":"@Component 和 @Bean 的区别是什么？"}]},{"ID":"20240926162309-a5l422z","Type":"NodeParagraph","Properties":{"id":"20240926162309-a5l422z","updated":"20240926175256"},"Children":[{"Type":"NodeText","Data":"这个问题可以扩大一点，变成SpringBoot中，有哪些方法定义Bean，各自有什么不同？"}]},{"ID":"20240926175257-w77ulvp","Type":"NodeParagraph","Properties":{"id":"20240926175257-w77ulvp","updated":"20240926175529"},"Children":[{"Type":"NodeText","Data":"基本的用于类的："},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"@Component"},{"Type":"NodeText","Data":"​表示通用注解、用于特定场合的还包括"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"@Repository @Service @Controller"},{"Type":"NodeText","Data":"​。"}]},{"ID":"20240926175555-6hongdz","Type":"NodeParagraph","Properties":{"id":"20240926175555-6hongdz","updated":"20240926175755"},"Children":[{"Type":"NodeText","Data":"除了这些以外，还包括@Bean，这个是定义在方法上的，表示这个方法构造了一个Bean，方法返回的实例会被Spring放入Ioc容器中。"}]},{"ID":"20240926175800-omlayw0","Type":"NodeParagraph","Properties":{"id":"20240926175800-omlayw0","updated":"20240926175825"},"Children":[{"Type":"NodeText","Data":"而这俩又有什么区别呢？"}]},{"ID":"20240926175826-z23isaw","Type":"NodeParagraph","Properties":{"id":"20240926175826-z23isaw","updated":"20240926180050"},"Children":[{"Type":"NodeText","Data":"从定义上就能看出，@Component 注解作用于类，而@Bean注解作用于方法。而@Component注解的类会在启动阶段通过类路径扫描自动扫描装载。@Bean则是在某个方法上定义，这样每当这个方法被调用的时候就会产生一个新的Bean。"}]},{"ID":"20240926175827-byfuxpn","Type":"NodeParagraph","Properties":{"id":"20240926175827-byfuxpn","updated":"20240926180139"},"Children":[{"Type":"NodeText","Data":"通常@Bean会用于把某些jar打包的第三方库引入Spring管理。"}]},{"ID":"20240926180140-s10hicr","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240926180140-s10hicr","updated":"20240926181022"},"Children":[{"Type":"NodeText","Data":"如何注入Bean，为什么@Autowired有时会被Warning。"}]},{"ID":"20240926180227-ixqolov","Type":"NodeParagraph","Properties":{"id":"20240926180227-ixqolov","updated":"20240926180643"},"Children":[{"Type":"NodeText","Data":"Spring 内置的 @Autowired 以及 JDK 内置的 @Resource 和 @Inject 都可以用于注入 Bean。注入的位置包括直接字段注入、Setter方法注入、构造函数注入。"}]},{"ID":"20240926180303-oj1v9et","Type":"NodeParagraph","Properties":{"id":"20240926180303-oj1v9et","updated":"20240926180315"},"Children":[{"Type":"NodeText","Data":"Autowired 属于 Spring 内置的注解，默认的注入方式为byType（根据类型进行匹配），也就是说会优先根据接口类型去匹配并注入 Bean （接口的实现类）。"}]},{"ID":"20240926180320-3yhq08a","Type":"NodeParagraph","Properties":{"id":"20240926180320-3yhq08a","updated":"20240926180346"},"Children":[{"Type":"NodeText","Data":"当一个接口存在多个实现类的话，byType这种方式就无法正确注入对象了，因为这个时候 Spring 会同时找到多个满足条件的选择，默认情况下它自己不知道选择哪一个。这种情况下，注入方式会变为 byName（根据名称进行匹配），这个名称通常就是类名（首字母小写）。"}]},{"ID":"20240926180350-t7rm6s7","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240926180350-t7rm6s7","updated":"20240926180354"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ=="},{"Type":"NodeCodeBlockCode","Data":"// 报错，byName 和 byType 都无法匹配到 bean\n@Autowired\nprivate SmsService smsService;\n// 正确注入 SmsServiceImpl1 对象对应的 bean\n@Autowired\nprivate SmsService smsServiceImpl1;\n// 正确注入  SmsServiceImpl1 对象对应的 bean\n// smsServiceImpl1 就是我们上面所说的名称\n@Autowired\n@Qualifier(value = \"smsServiceImpl1\")\nprivate SmsService smsService;\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240926180355-psckgt4","Type":"NodeParagraph","Properties":{"id":"20240926180355-psckgt4","updated":"20240926180427"},"Children":[{"Type":"NodeText","Data":"还是建议通过 @Qualifier 注解来显式指定名称而不是依赖变量的名称。"}]},{"ID":"20240926180424-peoz1af","Type":"NodeParagraph","Properties":{"id":"20240926180424-peoz1af","updated":"20240926180424"},"Children":[{"Type":"NodeText","Data":"@Resource属于 JDK 提供的注解，默认注入方式为 byName。如果无法通过名称匹配到对应的 Bean 的话，注入方式会变为byType。"}]},{"ID":"20240926180422-wmjan3m","Type":"NodeParagraph","Properties":{"id":"20240926180422-wmjan3m","updated":"20240926180452"},"Children":[{"Type":"NodeText","Data":"@Resource 有两个比较重要且日常开发常用的属性：name（名称）、type（类型）。如果仅指定 name 属性则注入方式为byName，如果仅指定type属性则注入方式为byType，如果同时指定name 和type属性（不建议这么做）则注入方式为byType+byName。"}]},{"ID":"20240926180453-z2wzmpq","Type":"NodeParagraph","Properties":{"id":"20240926180453-z2wzmpq","updated":"20240926180738"},"Children":[{"Type":"NodeText","Data":"从注入方式的角度方式考虑，Spring 官方推荐构造函数注入，这种注入方式的优势如下："}]},{"ID":"20240926180925-51r40kz","Type":"NodeList","ListData":{},"Properties":{"id":"20240926180925-51r40kz","updated":"20240926180925"},"Children":[{"ID":"20240926180925-mvaxgkk","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240926180925-mvaxgkk","updated":"20240926180925"},"Children":[{"ID":"20240926180908-lltlzv8","Type":"NodeParagraph","Properties":{"id":"20240926180908-lltlzv8","updated":"20240926180925"},"Children":[{"Type":"NodeText","Data":"依赖完整性：确保所有必需依赖在对象创建时就被注入，避免了空指针异常的风险。"}]}]},{"ID":"20240926180925-3r9iryl","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240926180925-3r9iryl","updated":"20240926180925"},"Children":[{"ID":"20240926180917-fq9wrt0","Type":"NodeParagraph","Properties":{"id":"20240926180917-fq9wrt0","updated":"20240926180925"},"Children":[{"Type":"NodeText","Data":"不可变性：有助于创建不可变对象，提高了线程安全性。"}]}]},{"ID":"20240926180925-yqxoihh","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240926180925-yqxoihh","updated":"20240926180925"},"Children":[{"ID":"20240926180918-0daczpi","Type":"NodeParagraph","Properties":{"id":"20240926180918-0daczpi","updated":"20240926180925"},"Children":[{"Type":"NodeText","Data":"初始化保证：组件在使用前已完全初始化，减少了潜在的错误。"}]}]},{"ID":"20240926180925-klcpv3l","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240926180925-klcpv3l","updated":"20240926180925"},"Children":[{"ID":"20240926180918-2owek5w","Type":"NodeParagraph","Properties":{"id":"20240926180918-2owek5w","updated":"20240926180925"},"Children":[{"Type":"NodeText","Data":"测试便利性：在单元测试中，可以直接通过构造函数传入模拟的依赖项，而不必依赖 Spring 容器进行注入。"}]}]}]},{"ID":"20240926180919-60wggb2","Type":"NodeParagraph","Properties":{"id":"20240926180919-60wggb2","updated":"20240926180919"},"Children":[{"Type":"NodeText","Data":"构造函数注入适合处理必需的依赖项，而 Setter 注入 则更适合可选的依赖项，这些依赖项可以有默认值或在对象生命周期中动态设置。虽然 @Autowired 可以用于 Setter 方法来处理必需的依赖项，但构造函数注入仍然是更好的选择。"}]},{"ID":"20240926180908-fcs8tmf","Type":"NodeParagraph","Properties":{"id":"20240926180908-fcs8tmf","updated":"20240926180908"},"Children":[{"Type":"NodeText","Data":"在某些情况下（例如第三方类不提供 Setter 方法），构造函数注入可能是唯一的选择。"}]},{"ID":"20240926180857-9snw1v9","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240926180857-9snw1v9","updated":"20240926183139"},"Children":[{"Type":"NodeText","Data":"Bean的作用域"}]},{"ID":"20240926181102-05krxjx","Type":"NodeParagraph","Properties":{"id":"20240926181102-05krxjx","updated":"20240926182523"},"Children":[{"Type":"NodeText","Data":"默认情况下，SpringBean是单例（singleton）模式，其作用域就是全局的，也是唯一单例的。"}]},{"ID":"20240926182505-rk8qlqt","Type":"NodeParagraph","Properties":{"id":"20240926182505-rk8qlqt","updated":"20240926182721"},"Children":[{"Type":"NodeText","Data":"除了单例模式之外，还有几种：每次调用都创建新的（prototype），每次http请求都创建新的（request），同一个HTTP Session共享一个Bean（session），（global session）。"}]},{"ID":"20240926182722-6m83rpf","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240926182722-6m83rpf","updated":"20240926182918"},"Children":[{"Type":"NodeText","Data":"singleton（默认）"}]},{"ID":"20240926182840-5xw0wrn","Type":"NodeParagraph","Properties":{"id":"20240926182840-5xw0wrn","updated":"20240926182911"},"Children":[{"Type":"NodeText","Data":"singleton 是单例类型(对应于单例模式)，就是在创建起容器时就同时自动创建了一个bean的对象，不管你是否使用。可以指定Bean节点的 lazy-init=”true” 来延迟初始化bean，这时候，只有在第一次获取bean时才会初始化bean。"}]},{"ID":"20240926182918-8o9747y","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240926182918-8o9747y","updated":"20240926183212"},"Children":[{"Type":"NodeText","Data":"prototype"}]},{"ID":"20240926183047-zrgglm1","Type":"NodeParagraph","Properties":{"id":"20240926183047-zrgglm1","updated":"20240926183117"},"Children":[{"Type":"NodeText","Data":"在每次对该 bean 请求（将其注入到另一个 bean 中，或者以程序的方式调用容器的 getBean() 方法）时都会创建一个新的 bean 实例。根据经验，对有状态的 bean 应该使用 prototype 作用域，而对无状态的 bean 则应该使用 singleton 作用域。"}]},{"ID":"20240926183118-vry1ilg","Type":"NodeParagraph","Properties":{"id":"20240926183118-vry1ilg","updated":"20240926183212"},"Children":[{"Type":"NodeText","Data":"剩下几个先不管"}]},{"ID":"20240926183203-5o1cx75","Type":"NodeHeading","HeadingLevel":2,"Properties":{"custom-riff-decks":"20230218211946-2kw8jgx","id":"20240926183203-5o1cx75","updated":"20241008094010"},"Children":[{"Type":"NodeTextMark","TextMarkType":"mark","TextMarkTextContent":"Bean的生命周期"}]},{"ID":"20240926183246-01mobg2","Type":"NodeParagraph","Properties":{"id":"20240926183246-01mobg2","updated":"20240929160451"},"Children":[{"Type":"NodeText","Data":"大致分为四个过程：实例化 -\u003e 属性赋值 -\u003e 初始化 -\u003e 销毁"}]},{"ID":"20240929160452-uzvgjdw","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20240929160452-uzvgjdw","updated":"20241008094010"},"Children":[{"ID":"20240929161147-bz9p0ef","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20240929161147-bz9p0ef","updated":"20240929161147"},"Children":[{"ID":"20240929161147-iq0euls","Type":"NodeParagraph","Properties":{"id":"20240929161147-iq0euls","updated":"20240929161631"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"创建 Bean 的实例"},{"Type":"NodeText","Data":"：Bean 容器首先会找到配置文件中的 Bean 定义，然后使用 "},{"Type":"NodeText","Data":"Java"},{"Type":"NodeText","Data":" 反射 API 来创建 Bean 的实例。"}]}]},{"ID":"20240929161150-tmr4xgi","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20240929161150-tmr4xgi","updated":"20240929161150"},"Children":[{"ID":"20240929161150-8n4rjkg","Type":"NodeParagraph","Properties":{"id":"20240929161150-8n4rjkg","updated":"20240929161634"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Bean 属性赋值/填充"},{"Type":"NodeText","Data":"：为 Bean 设置相关属性和依赖，例如@Autowired 等"},{"Type":"NodeText","Data":"注解"},{"Type":"NodeText","Data":"注入的对象、@Value 注入的值、setter方法或构造函数注入依赖和值、@Resource注入的各种资源。"}]}]},{"ID":"20240929161155-as4hkzz","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20240929161155-as4hkzz","updated":"20240929161727"},"Children":[{"ID":"20240929161155-cb0osax","Type":"NodeParagraph","Properties":{"id":"20240929161155-cb0osax","updated":"20240929161658"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Bean 初始化"},{"Type":"NodeText","Data":"："}]},{"ID":"20240929161658-6i9html","Type":"NodeList","ListData":{},"Properties":{"id":"20240929161658-6i9html","updated":"20240929161727"},"Children":[{"ID":"20240929161658-96cq6c6","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240929161658-96cq6c6","updated":"20240929161658"},"Children":[{"ID":"20240929161658-e5m828w","Type":"NodeParagraph","Properties":{"id":"20240929161658-e5m828w","updated":"20240929161658"},"Children":[{"Type":"NodeText","Data":"如果 Bean 实现了 BeanNameAware 接口，调用 setBeanName()方法，传入 Bean 的名字。"}]}]},{"ID":"20240929161701-s7lmdg0","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240929161701-s7lmdg0","updated":"20240929161701"},"Children":[{"ID":"20240929161701-yavsg7i","Type":"NodeParagraph","Properties":{"id":"20240929161701-yavsg7i","updated":"20240929161701"},"Children":[{"Type":"NodeText","Data":"如果 Bean 实现了 BeanClassLoaderAware 接口，调用 setBeanClassLoader()方法，传入 ClassLoader对象的实例。"}]}]},{"ID":"20240929161708-c0wunh7","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240929161708-c0wunh7","updated":"20240929161708"},"Children":[{"ID":"20240929161708-jnfye4y","Type":"NodeParagraph","Properties":{"id":"20240929161708-jnfye4y","updated":"20240929161710"},"Children":[{"Type":"NodeText","Data":"如果 Bean 实现了 BeanFactoryAware 接口，调用 setBeanFactory()方法，传入 BeanFactory对象的实例。"}]}]},{"ID":"20240929161710-ax9aey7","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240929161710-ax9aey7","updated":"20240929161710"},"Children":[{"ID":"20240929161710-nkai2kz","Type":"NodeParagraph","Properties":{"id":"20240929161710-nkai2kz","updated":"20240929161711"},"Children":[{"Type":"NodeText","Data":"与上面的类似，如果实现了其他 *.Aware接口，就调用相应的方法。"}]}]},{"ID":"20240929161718-07xk1x4","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240929161718-07xk1x4","updated":"20240929161718"},"Children":[{"ID":"20240929161718-x6ga1lm","Type":"NodeParagraph","Properties":{"id":"20240929161718-x6ga1lm","updated":"20240929161719"},"Children":[{"Type":"NodeText","Data":"如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象，执行postProcessBeforeInitialization() 方法"}]}]},{"ID":"20240929161720-tcudedq","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240929161720-tcudedq","updated":"20240929161720"},"Children":[{"ID":"20240929161720-zv068wy","Type":"NodeParagraph","Properties":{"id":"20240929161720-zv068wy","updated":"20240929161721"},"Children":[{"Type":"NodeText","Data":"如果 Bean 实现了InitializingBean接口，执行afterPropertiesSet()方法。"}]}]},{"ID":"20240929161723-6lilkrc","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240929161723-6lilkrc","updated":"20240929161723"},"Children":[{"ID":"20240929161723-0l7zj54","Type":"NodeParagraph","Properties":{"id":"20240929161723-0l7zj54","updated":"20240929161724"},"Children":[{"Type":"NodeText","Data":"如果 Bean 在配置文件中的定义包含 init-method 属性，执行指定的方法。"}]}]},{"ID":"20240929161725-qez2e06","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240929161725-qez2e06","updated":"20240929161727"},"Children":[{"ID":"20240929161725-8mtm44n","Type":"NodeParagraph","Properties":{"id":"20240929161725-8mtm44n","updated":"20240929161727"},"Children":[{"Type":"NodeText","Data":"如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象，执行postProcessAfterInitialization() 方法。"}]}]}]}]},{"ID":"20240929161623-az7a47x","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"NC4=","Num":4},"Properties":{"id":"20240929161623-az7a47x","updated":"20241008094010"},"Children":[{"ID":"20240929161623-aa4fnft","Type":"NodeParagraph","Properties":{"id":"20240929161623-aa4fnft","updated":"20241008094010"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"销毁 Bean"},{"Type":"NodeText","Data":"：\n销毁并不是说要立马把 Bean 给销毁掉，而是把 Bean 的销毁方法先记录下来，将来需要销毁 Bean 或者销毁容器的时候，就调用这些方法去释放 Bean 所持有的资源。\n如果 Bean 实现了 DisposableBean 接口，执行 destroy() 方法。\n如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的 Bean 销毁方法。或者，也可以直接通过@PreDestroy "},{"Type":"NodeText","Data":"注解"},{"Type":"NodeText","Data":"标记 Bean 销毁之前执行的方法。"}]}]}]},{"ID":"20241008113214-hu4in95","Type":"NodeParagraph","Properties":{"id":"20241008113214-hu4in95","updated":"20241008113215"}},{"ID":"20240929161628-5szkt8s","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240929161628-5szkt8s","updated":"20241008133034"},"Children":[{"Type":"NodeText","Data":"Bean线程安全"}]},{"ID":"20241008100924-id91wdn","Type":"NodeParagraph","Properties":{"id":"20241008100924-id91wdn","updated":"20241008102023"},"Children":[{"Type":"NodeText","Data":"SpringBean本身没有线程安全特性，如果是prototype则无需考虑这个问题，因为每次请求都使用新的对象，只需要讨论singleton作用域时的线程安全性。"}]},{"ID":"20241008102046-m65dgs2","Type":"NodeParagraph","Properties":{"id":"20241008102046-m65dgs2","updated":"20241008102046"},"Children":[{"Type":"NodeText","Data":"singleton 作用域下，IoC 容器中只有唯一的 bean 实例，可能会存在资源竞争问题（取决于 Bean 是否有状态）。如果这个 bean 是有状态的话，那就存在线程安全问题（有状态 Bean 是指包含可变的成员变量的对象）。"}]},{"ID":"20241008101424-m4bi3ze","Type":"NodeParagraph","Properties":{"id":"20241008101424-m4bi3ze","updated":"20241008102122"},"Children":[{"Type":"NodeText","Data":"例如这个bean就是有状态的："}]},{"ID":"20241008102124-2lz8v4a","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20241008102124-2lz8v4a","updated":"20241008103923"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ=="},{"Type":"NodeCodeBlockCode","Data":"// 定义了一个购物车类，其中包含一个保存用户的购物车里商品的 List\n@Component\npublic class ShoppingCart {\n    private List\u003cString\u003e items = new ArrayList\u003c\u003e();\n\n    public void addItem(String item) {\n        items.add(item);\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20241008102126-8qbjee5","Type":"NodeParagraph","Properties":{"id":"20241008102126-8qbjee5","updated":"20241008102624"},"Children":[{"Type":"NodeText","Data":"这种情况下，就需要做特别处理保证线程安全，当然通常需要尽量避免这种情况。"}]},{"ID":"20241008102639-9pnfgai","Type":"NodeParagraph","Properties":{"id":"20241008102639-9pnfgai","updated":"20241008102654"},"Children":[{"Type":"NodeText","Data":"对于有状态单例 Bean 的线程安全问题，常见的解决办法是："}]},{"ID":"20241008102648-s7zrjea","Type":"NodeList","ListData":{},"Properties":{"id":"20241008102648-s7zrjea","updated":"20241008103926"},"Children":[{"ID":"20241008102702-u7x8n7f","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20241008102702-u7x8n7f","updated":"20241008102702"},"Children":[{"ID":"20241008102702-jezoglc","Type":"NodeParagraph","Properties":{"id":"20241008102702-jezoglc","updated":"20241008102702"},"Children":[{"Type":"NodeText","Data":"使用ThreadLocal: 将可变成员变量保存在 ThreadLocal 中，确保线程独立。"}]}]},{"ID":"20241008102705-svx8u9i","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20241008102705-svx8u9i","updated":"20241008103926"},"Children":[{"ID":"20241008102705-viv2dug","Type":"NodeParagraph","Properties":{"id":"20241008102705-viv2dug","updated":"20241008103648"},"Children":[{"Type":"NodeText","Data":"使用同步机制: 利用 synchronized 或 ReentrantLock 来进行同步控制，确保线程安全。"}]},{"ID":"20241008103702-2r5tbk4","Type":"NodeList","ListData":{},"Properties":{"id":"20241008103702-2r5tbk4","updated":"20241008103926"},"Children":[{"ID":"20241008103701-n6o7bt2","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20241008103701-n6o7bt2","updated":"20241008103703"},"Children":[{"ID":"20241008103701-nfixb1f","Type":"NodeParagraph","Properties":{"id":"20241008103701-nfixb1f","updated":"20241008103703"},"Children":[{"Type":"NodeText","Data":"synchronized关键字可以用来修饰方法或者代码块。当一个方法被synchronized修饰时，那么每次只有一个线程能够执行该方法。如果一个代码块被synchronized修饰，那么在同一时间只有一个线程能够执行该代码块。"}]}]},{"ID":"20241008103704-o3qzoe8","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20241008103704-o3qzoe8","updated":"20241008103926"},"Children":[{"ID":"20241008103756-8rdojo9","Type":"NodeParagraph","Properties":{"id":"20241008103756-8rdojo9","updated":"20241008103829"},"Children":[{"Type":"NodeText","Data":"ReentrantLock类似一个手动操作的锁，如示例所示。"}]},{"ID":"20241008103716-1h4o4ye","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20241008103716-1h4o4ye","updated":"20241008103926"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ=="},{"Type":"NodeCodeBlockCode","Data":"import java.util.concurrent.locks.ReentrantLock;\n\npublic class Counter {\n    private int count = 0;\n    private final ReentrantLock lock = new ReentrantLock();\n\n    public void increment() {\n        lock.lock(); // 获取锁\n        try {\n            count++;\n        } finally {\n            lock.unlock(); // 释放锁\n        }\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]}]}]}]}]},{"ID":"20241008133034-cve0rls","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20241008133034-cve0rls","updated":"20241010190820"},"Children":[{"Type":"NodeText","Data":"Spring循环依赖"}]},{"ID":"20241010185020-0blqqqy","Type":"NodeParagraph","Properties":{"id":"20241010185020-0blqqqy","updated":"20241010185029"},"Children":[{"Type":"NodeText","Data":"循环依赖是指 Bean 对象循环引用，是两个或多个 Bean 之间相互持有对方的引用，例如 CircularDependencyA → CircularDependencyB → CircularDependencyA。"}]},{"ID":"20241010185029-dt5wswo","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20241010185029-dt5wswo","updated":"20241010185103"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ=="},{"Type":"NodeCodeBlockCode","Data":"@Component\npublic class CircularDependencyA {\n    @Autowired\n    private CircularDependencyB circB;\n}\n\n@Component\npublic class CircularDependencyB {\n    @Autowired\n    private CircularDependencyA circA;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20241010185104-vgq0j34","Type":"NodeParagraph","Properties":{"id":"20241010185104-vgq0j34","updated":"20241010190233"},"Children":[{"Type":"NodeText","Data":"像这样的情况，"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"首先是一个设计问题"},{"Type":"NodeText","Data":"，设计上不应该出现这样的情况，而且SpringBoot现在的版本在默认情况下也不支持这种情况。"}]},{"ID":"20241010185403-6o8mpbl","Type":"NodeParagraph","Properties":{"id":"20241010185403-6o8mpbl","updated":"20241010190130"},"Children":[{"Type":"NodeText","Data":"但Spring对这种情况是有解决方案的，核心是使用三层缓存（说是缓存，准确来说应该来说就是三层map）。"}]},{"ID":"20241010190138-j8407vs","Type":"NodeParagraph","Properties":{"id":"20241010190138-j8407vs","updated":"20241010190138"},"Children":[{"Type":"NodeText","Data":"简单来说，Spring 的三级缓存包括："}]},{"ID":"20241010190138-v2jech0","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20241010190138-v2jech0","updated":"20241010190149"},"Children":[{"ID":"20241010190138-ty1r0mm","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20241010190138-ty1r0mm","updated":"20241010190149"},"Children":[{"ID":"20241010190138-e54a7go","Type":"NodeParagraph","Properties":{"id":"20241010190138-e54a7go","updated":"20241010190149"},"Children":[{"Type":"NodeText","Data":"一级缓存（singletonObjects）：存放最终形态的 Bean（已经实例化、属性填充、初始化），单例池，为“Spring 的单例属性”⽽⽣。一般情况我们获取 Bean 都是从这里获取的，但是并不是所有的 Bean 都在单例池里面，例如原型 Bean 就不在里面。"}]}]},{"ID":"20241010190138-bvabcog","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20241010190138-bvabcog","updated":"20241010190146"},"Children":[{"ID":"20241010190138-yacmpu8","Type":"NodeParagraph","Properties":{"id":"20241010190138-yacmpu8","updated":"20241010190146"},"Children":[{"Type":"NodeText","Data":"二级缓存（earlySingletonObjects）：存放过渡 Bean（半成品，尚未属性填充），也就是三级缓存中"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"ObjectFactory"},{"Type":"NodeText","Data":"​产生的对象，与三级缓存配合使用的，可以防止 AOP 的情况下，每次调用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"ObjectFactory#getObject()"},{"Type":"NodeText","Data":"​都是会产生新的代理对象的。"}]}]},{"ID":"20241010190138-d5urh81","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20241010190138-d5urh81","updated":"20241010190145"},"Children":[{"ID":"20241010190138-2w3k3h8","Type":"NodeParagraph","Properties":{"id":"20241010190138-2w3k3h8","updated":"20241010190145"},"Children":[{"Type":"NodeText","Data":"三级缓存（singletonFactories）：存放"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"ObjectFactory"},{"Type":"NodeText","Data":"​，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"ObjectFactory"},{"Type":"NodeText","Data":"​的"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"getObject()"},{"Type":"NodeText","Data":"​方法（最终调用的是"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"getEarlyBeanReference()"},{"Type":"NodeText","Data":"​方法）可以生成原始 Bean 对象或者代理对象（如果 Bean 被 AOP 切面代理）。三级缓存只会对单例 Bean 生效。"}]}]}]},{"ID":"20241010190304-4pcfi82","Type":"NodeParagraph","Properties":{"id":"20241010190304-4pcfi82","updated":"20241010190304"},"Children":[{"Type":"NodeText","Data":"接下来说一下 Spring 创建 Bean 的流程："}]},{"ID":"20241010190304-tifhdgf","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20241010190304-tifhdgf","updated":"20241010190304"},"Children":[{"ID":"20241010190304-9ypknh2","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20241010190304-9ypknh2","updated":"20241010190304"},"Children":[{"ID":"20241010190304-0cb4hrb","Type":"NodeParagraph","Properties":{"id":"20241010190304-0cb4hrb","updated":"20241010190304"},"Children":[{"Type":"NodeText","Data":"先去 **一级缓存 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"singletonObjects"},{"Type":"NodeText","Data":"​** 中获取，存在就返回；"}]}]},{"ID":"20241010190304-pmw5ya3","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20241010190304-pmw5ya3","updated":"20241010190304"},"Children":[{"ID":"20241010190304-sr1qzjc","Type":"NodeParagraph","Properties":{"id":"20241010190304-sr1qzjc","updated":"20241010190304"},"Children":[{"Type":"NodeText","Data":"如果不存在或者对象正在创建中，于是去 **二级缓存 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"earlySingletonObjects"},{"Type":"NodeText","Data":"​** 中获取；"}]}]},{"ID":"20241010190304-8rm9uib","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20241010190304-8rm9uib","updated":"20241010190304"},"Children":[{"ID":"20241010190304-annrbzz","Type":"NodeParagraph","Properties":{"id":"20241010190304-annrbzz","updated":"20241010190304"},"Children":[{"Type":"NodeText","Data":"如果还没有获取到，就去 **三级缓存 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"singletonFactories"},{"Type":"NodeText","Data":"​** 中获取，通过执行 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"ObjectFacotry"},{"Type":"NodeText","Data":"​ 的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"getObject()"},{"Type":"NodeText","Data":"​ 就可以获取该对象，获取成功之后，从三级缓存移除，并将该对象加入到二级缓存中。"}]}]}]},{"ID":"20241010190308-kq1jodj","Type":"NodeParagraph","Properties":{"id":"20241010190308-kq1jodj","updated":"20241010190603"},"Children":[{"Type":"NodeText","Data":"显然，初始化A的过程中，A是放在三级缓存里面的。此时因为依赖B，所以转而去初始化B，B又需要A，此时产生冲突，而Spring的解决方案是直接去三级缓存里面把A的引用先放过来，这样就解决了循环依赖的问题。"}]},{"ID":"20241010190603-iz90t7g","Type":"NodeParagraph","Properties":{"id":"20241010190603-iz90t7g","updated":"20241010190815"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"LazyLoad也可以解决循环依赖的问题"},{"Type":"NodeText","Data":"，还是刚刚的情况，由于在 A 上标注了 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"@Lazy"},{"Type":"NodeText","Data":"​ 注解，因此 Spring 会去创建一个 B 的代理对象，将这个代理对象注入到 A 中的 B 属性，不会去实际注入B，也就没有循环依赖的问题。"}]},{"ID":"20241010190207-s4647l2","Type":"NodeThematicBreak","Properties":{"id":"20241010190207-s4647l2","updated":"20241010190207"}},{"ID":"20241010190208-gb3zeyo","Type":"NodeBlockquote","Properties":{"id":"20241010190208-gb3zeyo","updated":"20241010190223"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20241010190216-lqnj670","Type":"NodeParagraph","Properties":{"id":"20241010190216-lqnj670","updated":"20241010190223"},"Children":[{"Type":"NodeText","Data":"著作权归JavaGuide(javaguide.cn)所有 基于MIT协议 原文链接："},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html","TextMarkTextContent":"https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html"}]}]},{"ID":"20241010190820-1xn91qu","Type":"NodeParagraph","Properties":{"id":"20241010190820-1xn91qu","updated":"20241010190820"}}]}