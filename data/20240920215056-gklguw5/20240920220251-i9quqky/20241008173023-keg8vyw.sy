{"ID":"20241008173023-keg8vyw","Spec":"1","Type":"NodeDocument","Properties":{"custom-common-Halo-yaml":"---_esc_newline_created: '2024-10-08 17:30:23'_esc_newline_updated: '2024-10-08 18:00:54'_esc_newline_title: 哈希表_esc_newline_slug: hash-table-gig58_esc_newline_permalink: siyuan://blocks/20241008173023-keg8vyw_esc_newline_tags:_esc_newline_  - 数据结构_esc_newline_  - 算法_esc_newline_categories: []_esc_newline_---","custom-picgo-file-map-key":"\u0026#123;\u0026quot;fc2b8e3a822efac3d4ac9d5d0de1cfdd\u0026quot;:\u0026#123;\u0026quot;name\u0026quot;:\u0026quot;image-20241008174135-q0xess5.png\u0026quot;,\u0026quot;hash\u0026quot;:\u0026quot;fc2b8e3a822efac3d4ac9d5d0de1cfdd\u0026quot;,\u0026quot;originUrl\u0026quot;:\u0026quot;assets/image-20241008174135-q0xess5.png\u0026quot;,\u0026quot;url\u0026quot;:\u0026quot;https://syc-test111.oss-cn-chengdu.aliyuncs.com/image-20241008174135-q0xess5.png\u0026quot;,\u0026quot;alt\u0026quot;:\u0026quot;image\u0026quot;,\u0026quot;title\u0026quot;:\u0026quot;\u0026quot;,\u0026quot;isLocal\u0026quot;:false,\u0026quot;blockId\u0026quot;:\u0026quot;20241008174135-ls6vsoe\u0026quot;\u0026#125;,\u0026quot;5dd256e8e3b3bea29de17b056182b60e\u0026quot;:\u0026#123;\u0026quot;name\u0026quot;:\u0026quot;image-20241008173947-djr3xm2.png\u0026quot;,\u0026quot;hash\u0026quot;:\u0026quot;5dd256e8e3b3bea29de17b056182b60e\u0026quot;,\u0026quot;originUrl\u0026quot;:\u0026quot;assets/image-20241008173947-djr3xm2.png\u0026quot;,\u0026quot;url\u0026quot;:\u0026quot;https://syc-test111.oss-cn-chengdu.aliyuncs.com/image-20241008173947-djr3xm2.png\u0026quot;,\u0026quot;alt\u0026quot;:\u0026quot;image\u0026quot;,\u0026quot;title\u0026quot;:\u0026quot;\u0026quot;,\u0026quot;isLocal\u0026quot;:false,\u0026quot;blockId\u0026quot;:\u0026quot;20241008174135-ls6vsoe\u0026quot;\u0026#125;\u0026#125;","id":"20241008173023-keg8vyw","tags":"数据结构,算法","title":"哈希表","type":"doc","updated":"20241008212846"},"Children":[{"ID":"20241008173048-slepfbu","Type":"NodeParagraph","Properties":{"id":"20241008173048-slepfbu","updated":"20241008173108"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"哈希表是根据关键码的值而直接进行访问的数据结构。"}]},{"ID":"20241008173109-6eh9sfb","Type":"NodeParagraph","Properties":{"id":"20241008173109-6eh9sfb","updated":"20241008193411"},"Children":[{"Type":"NodeText","Data":"那么哈希表能解决什么问题呢，一般哈希表都是用来"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"快速判断一个元素是否出现集合里"},{"Type":"NodeText","Data":"。要枚举的话时间复杂度是O(n)，但如果使用哈希表的话， 只需要O(1)就可以做到。"}]},{"ID":"20241008174015-bwbyunz","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20241008174015-bwbyunz","updated":"20241008174023"},"Children":[{"Type":"NodeText","Data":"原理"}]},{"ID":"20241008173920-qnu35r0","Type":"NodeParagraph","Properties":{"id":"20241008173920-qnu35r0","updated":"20241008174007"},"Children":[{"Type":"NodeText","Data":"我们先考虑最简单的情况，仅用一个数组来实现哈希表。在哈希表中，我们将数组中的每个空位称为桶（bucket），每个桶可存储一个键值对。因此，查询操作就是找到 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"key"},{"Type":"NodeText","Data":"​ 对应的桶，并在桶中获取 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"value"},{"Type":"NodeText","Data":"​ 。"}]},{"ID":"20241008173920-8xwyygf","Type":"NodeParagraph","Properties":{"id":"20241008173920-8xwyygf","updated":"20241008173920"},"Children":[{"Type":"NodeText","Data":"那么，如何基于 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"key"},{"Type":"NodeText","Data":"​ 定位对应的桶呢？这是通过哈希函数（hash function）实现的。哈希函数的作用是将一个较大的输入空间映射到一个较小的输出空间。在哈希表中，输入空间是所有 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"key"},{"Type":"NodeText","Data":"​ ，输出空间是所有桶（数组索引）。换句话说，输入一个 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"key"},{"Type":"NodeText","Data":"​ ，**我们可以通过哈希函数得到该 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"key"},{"Type":"NodeText","Data":"​ 对应的键值对在数组中的存储位置**。"}]},{"ID":"20241008173920-dd3lx5x","Type":"NodeParagraph","Properties":{"id":"20241008173920-dd3lx5x","updated":"20241008173920"},"Children":[{"Type":"NodeText","Data":"输入一个 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"key"},{"Type":"NodeText","Data":"​ ，哈希函数的计算过程分为以下两步。"}]},{"ID":"20241008173920-ojlfdbe","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20241008173920-ojlfdbe","updated":"20241008173920"},"Children":[{"ID":"20241008173846-r5gvsmg","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20241008173846-r5gvsmg","updated":"20241008173846"},"Children":[{"ID":"20241008173920-mgjj8tx","Type":"NodeParagraph","Properties":{"id":"20241008173920-mgjj8tx","updated":"20241008173920"},"Children":[{"Type":"NodeText","Data":"通过某种哈希算法 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"hash()"},{"Type":"NodeText","Data":"​ 计算得到哈希值。"}]}]},{"ID":"20241008173846-ghdg5ut","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20241008173846-ghdg5ut","updated":"20241008173846"},"Children":[{"ID":"20241008173920-k1x1v0v","Type":"NodeParagraph","Properties":{"id":"20241008173920-k1x1v0v","updated":"20241008173920"},"Children":[{"Type":"NodeText","Data":"将哈希值对桶数量（数组长度）"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"capacity"},{"Type":"NodeText","Data":"​ 取模，从而获取该 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"key"},{"Type":"NodeText","Data":"​ 对应的数组索引 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"index"},{"Type":"NodeText","Data":"​ 。"}]}]}]},{"ID":"20241008173920-i3ghfp6","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20241008173920-i3ghfp6","updated":"20241008173920"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"index = hash(key) % capacity\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20241008173920-db5kq05","Type":"NodeParagraph","Properties":{"id":"20241008173920-db5kq05","updated":"20241008173920"},"Children":[{"Type":"NodeText","Data":"随后，我们就可以利用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"index"},{"Type":"NodeText","Data":"​ 在哈希表中访问对应的桶，从而获取 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"value"},{"Type":"NodeText","Data":"​ 。"}]},{"ID":"20241008173920-l8knz8q","Type":"NodeParagraph","Properties":{"id":"20241008173920-l8knz8q","updated":"20241008173920"},"Children":[{"Type":"NodeText","Data":"设数组长度 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"capacity = 100"},{"Type":"NodeText","Data":"​、哈希算法 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"hash(key) = key"},{"Type":"NodeText","Data":"​ ，易得哈希函数为 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"key % 100"},{"Type":"NodeText","Data":"​ 。图 6-2 以 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"key"},{"Type":"NodeText","Data":"​ 学号和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"value"},{"Type":"NodeText","Data":"​ 姓名为例，展示了哈希函数的工作原理。"}]},{"ID":"20241008173947-c011vi6","Type":"NodeParagraph","Properties":{"id":"20241008173947-c011vi6","updated":"20241008173947"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20241008173947-djr3xm2.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20241008173948-hehif82","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20241008173948-hehif82","updated":"20241008212846"},"Children":[{"Type":"NodeText","Data":"Hash冲突"}]},{"ID":"20241008174149-cnydq9f","Type":"NodeParagraph","Properties":{"id":"20241008174149-cnydq9f","updated":"20241008174153"},"Children":[{"Type":"NodeText","Data":"从本质上看，哈希函数的作用是将所有 key 构成的输入空间映射到数组所有索引构成的输出空间，而输入空间往往远大于输出空间。因此，理论上一定存在“多个输入对应相同输出”的情况。"}]},{"ID":"20241008174153-dhzx1p1","Type":"NodeParagraph","Properties":{"id":"20241008174153-dhzx1p1","updated":"20241008174156"},"Children":[{"Type":"NodeText","Data":"如图所示"}]},{"ID":"20241008174135-ls6vsoe","Type":"NodeParagraph","Properties":{"id":"20241008174135-ls6vsoe","updated":"20241008180055"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"https://syc-test111.oss-cn-chengdu.aliyuncs.com/image-20241008174135-q0xess5.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20241008174157-ot1ch73","Type":"NodeParagraph","Properties":{"id":"20241008174157-ot1ch73","updated":"20241008212846"},"Children":[{"Type":"NodeText","Data":"哈希表的结构改良方法主要包括“链式地址”和“开放寻址”，已经理解了不细写。"}]},{"ID":"20241008175213-cdy5twu","Type":"NodeParagraph","Properties":{"id":"20241008175213-cdy5twu","updated":"20241008175238"},"Children":[{"Type":"NodeText","Data":"具体见："},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://www.hello-algo.com/chapter_hashing/hash_collision/","TextMarkTextContent":"https://www.hello-algo.com/chapter_hashing/hash_collision/"}]},{"ID":"20241008175221-uwg89rb","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20241008175221-uwg89rb","updated":"20241008175910"},"Children":[{"Type":"NodeText","Data":"C++的HashMap"}]},{"ID":"20241008175524-celx27h","Type":"NodeParagraph","Properties":{"id":"20241008175524-celx27h","updated":"20241008175524"},"Children":[{"Type":"NodeText","Data":"当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。"}]},{"ID":"20241008175524-ir26tjj","Type":"NodeList","ListData":{},"Properties":{"id":"20241008175524-ir26tjj","updated":"20241008175524"},"Children":[{"ID":"20241008175348-00q1j0x","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20241008175348-00q1j0x","updated":"20241008175348"},"Children":[{"ID":"20241008175524-7kgga1h","Type":"NodeParagraph","Properties":{"id":"20241008175524-7kgga1h","updated":"20241008175524"},"Children":[{"Type":"NodeText","Data":"数组"}]}]},{"ID":"20241008175348-bxt8bc5","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20241008175348-bxt8bc5","updated":"20241008175348"},"Children":[{"ID":"20241008175524-5w1klz2","Type":"NodeParagraph","Properties":{"id":"20241008175524-5w1klz2","updated":"20241008175524"},"Children":[{"Type":"NodeText","Data":"set （集合）"}]}]},{"ID":"20241008175348-gi3ogfl","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20241008175348-gi3ogfl","updated":"20241008175348"},"Children":[{"ID":"20241008175524-xnk7k0t","Type":"NodeParagraph","Properties":{"id":"20241008175524-xnk7k0t","updated":"20241008175524"},"Children":[{"Type":"NodeText","Data":"map(映射)"}]}]}]},{"ID":"20241008175524-rlt4kg0","Type":"NodeParagraph","Properties":{"id":"20241008175524-rlt4kg0","updated":"20241008175524"},"Children":[{"Type":"NodeText","Data":"这里数组就没啥可说的了，我们来看一下set。"}]},{"ID":"20241008175524-2slcv71","Type":"NodeParagraph","Properties":{"id":"20241008175524-2slcv71","updated":"20241008175524"},"Children":[{"Type":"NodeText","Data":"在C++中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示："}]},{"ID":"20241008175524-8xnyi6e","Type":"NodeTable","TableAligns":[0,0,0,0,0,0,0],"Properties":{"colgroup":"||||||","id":"20241008175524-8xnyi6e","updated":"20241008175524"},"Children":[{"Type":"NodeTableHead","Data":"thead","Children":[{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"th","Children":[{"Type":"NodeText","Data":"集合"}]},{"Type":"NodeTableCell","Data":"th","Children":[{"Type":"NodeText","Data":"底层实现"}]},{"Type":"NodeTableCell","Data":"th","Children":[{"Type":"NodeText","Data":"是否有序"}]},{"Type":"NodeTableCell","Data":"th","Children":[{"Type":"NodeText","Data":"数值是否可以重复"}]},{"Type":"NodeTableCell","Data":"th","Children":[{"Type":"NodeText","Data":"能否更改数值"}]},{"Type":"NodeTableCell","Data":"th","Children":[{"Type":"NodeText","Data":"查询效率"}]},{"Type":"NodeTableCell","Data":"th","Children":[{"Type":"NodeText","Data":"增删效率"}]}]}]},{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"std::set"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"红黑树"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"有序"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"否"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"否"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"O(log n)"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"O(log n)"}]}]},{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"std::multiset"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"红黑树"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"有序"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"是"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"否"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"O(logn)"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"O(logn)"}]}]},{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"std::unordered"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"_"}]},{"Type":"NodeText","Data":"set"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"哈希表"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"无序"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"否"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"否"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"O(1)"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"O(1)"}]}]}]},{"ID":"20241008175524-96qm24g","Type":"NodeParagraph","Properties":{"id":"20241008175524-96qm24g","updated":"20241008175524"},"Children":[{"Type":"NodeText","Data":"std::unordered"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"_"}]},{"Type":"NodeText","Data":"set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。"}]},{"ID":"20241008175524-3mixuu6","Type":"NodeTable","TableAligns":[0,0,0,0,0,0,0],"Properties":{"colgroup":"||||||","id":"20241008175524-3mixuu6","updated":"20241008175524"},"Children":[{"Type":"NodeTableHead","Data":"thead","Children":[{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"th","Children":[{"Type":"NodeText","Data":"映射"}]},{"Type":"NodeTableCell","Data":"th","Children":[{"Type":"NodeText","Data":"底层实现"}]},{"Type":"NodeTableCell","Data":"th","Children":[{"Type":"NodeText","Data":"是否有序"}]},{"Type":"NodeTableCell","Data":"th","Children":[{"Type":"NodeText","Data":"数值是否可以重复"}]},{"Type":"NodeTableCell","Data":"th","Children":[{"Type":"NodeText","Data":"能否更改数值"}]},{"Type":"NodeTableCell","Data":"th","Children":[{"Type":"NodeText","Data":"查询效率"}]},{"Type":"NodeTableCell","Data":"th","Children":[{"Type":"NodeText","Data":"增删效率"}]}]}]},{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"std::map"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"红黑树"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"key有序"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"key不可重复"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"key不可修改"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"O(logn)"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"O(logn)"}]}]},{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"std::multimap"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"红黑树"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"key有序"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"key可重复"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"key不可修改"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"O(log n)"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"O(log n)"}]}]},{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"std::unordered"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"_"}]},{"Type":"NodeText","Data":"map"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"哈希表"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"key无序"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"key不可重复"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"key不可修改"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"O(1)"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"O(1)"}]}]}]},{"ID":"20241008175524-12lbeoh","Type":"NodeParagraph","Properties":{"id":"20241008175524-12lbeoh","updated":"20241008175524"},"Children":[{"Type":"NodeText","Data":"std::unordered"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"_"}]},{"Type":"NodeText","Data":"map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。"}]},{"ID":"20241008175524-u38i5vm","Type":"NodeParagraph","Properties":{"id":"20241008175524-u38i5vm","updated":"20241008175910"},"Children":[{"Type":"NodeText","Data":"当我们要使用集合来解决哈希问题的时候，优先使用unordered"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"_"}]},{"Type":"NodeText","Data":"set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。"},{"Type":"NodeTextMark","TextMarkType":"em","TextMarkTextContent":"map同理"}]},{"ID":"20241008175848-xvlygek","Type":"NodeParagraph","Properties":{"id":"20241008175848-xvlygek","updated":"20241008175851"},"Children":[{"Type":"NodeText","Data":"常用操作"}]},{"ID":"20241008175833-v31ap29","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20241008175833-v31ap29","updated":"20241008175839"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"/* 初始化哈希表 */\nunordered_map\u003cint, string\u003e map;\n\n/* 添加操作 */\n// 在哈希表中添加键值对 (key, value)\nmap[12836] = \"小哈\";\nmap[15937] = \"小啰\";\nmap[16750] = \"小算\";\nmap[13276] = \"小法\";\nmap[10583] = \"小鸭\";\n\n/* 查询操作 */\n// 向哈希表中输入键 key ，得到值 value\nstring name = map[15937];\n\n/* 删除操作 */\n// 在哈希表中删除键值对 (key, value)\nmap.erase(10583);\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20241008175834-7hsh259","Type":"NodeParagraph","Properties":{"id":"20241008175834-7hsh259","updated":"20241008175834"}}]}