{"ID":"20240920215040-vws4r96","Spec":"1","Type":"NodeDocument","Properties":{"id":"20240920215040-vws4r96","tags":"算法,数据结构","title":"基础速通","type":"doc","updated":"20240920215401"},"Children":[{"ID":"20240920215041-9q0nm2s","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240920215041-9q0nm2s","updated":"20240920215041"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"# ","Properties":{"id":""}},{"Type":"NodeText","Data":"基础速通"}]},{"ID":"20240920215042-9rz58r4","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240920215042-9rz58r4","updated":"20240920215042"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"复杂度分析"}]},{"ID":"20240920215043-0nxkson","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240920215043-0nxkson","updated":"20240920215043"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"时间复杂度的计算方法"}]},{"ID":"20240920215044-ikhfk0w","Type":"NodeParagraph","Properties":{"id":"20240920215044-ikhfk0w","updated":"20240920215044"},"Children":[{"Type":"NodeText","Data":"针对代码，逐行从上到下计算代码一共的操作次数即可。此操作数量中的各种系数、常数项都可以忽略。根据此原则，可以总结出以下计数简化技巧。"}]},{"ID":"20240920215045-qpxj9eu","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240920215045-qpxj9eu","updated":"20240920215045"},"Children":[{"ID":"20240920215046-e58kp7q","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240920215046-e58kp7q","updated":"20240920215046"},"Children":[{"ID":"20240920215047-8zu2bwn","Type":"NodeParagraph","Properties":{"id":"20240920215047-8zu2bwn","updated":"20240920215047"},"Children":[{"Type":"NodeText","Data":"忽略循环次数中的常数项。因为它们都与n无关，所以对时间复杂度不产生影响。"}]}]},{"ID":"20240920215048-ns1q519","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240920215048-ns1q519","updated":"20240920215048"},"Children":[{"ID":"20240920215049-isbqjr9","Type":"NodeParagraph","Properties":{"id":"20240920215049-isbqjr9","updated":"20240920215049"},"Children":[{"Type":"NodeText","Data":"省略所有系数，因为前面的系数对时间复杂度没有影响。"}]}]},{"ID":"20240920215050-emthclm","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240920215050-emthclm","updated":"20240920215050"},"Children":[{"ID":"20240920215051-y38pgwh","Type":"NodeParagraph","Properties":{"id":"20240920215051-y38pgwh","updated":"20240920215051"},"Children":[{"Type":"NodeText","Data":"循环嵌套时使用乘法。总操作数量等于外层循环和内层循环操作数量之积，每一层循环依然可以分别套用第1点和第2点的技巧。"}]}]}]},{"ID":"20240920215052-4kscj5b","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240920215052-4kscj5b","updated":"20240920215401"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"空间复杂度的计算方法"}]},{"ID":"20240920215053-xkr7hmc","Type":"NodeParagraph","Properties":{"id":"20240920215053-xkr7hmc","updated":"20240920215053"},"Children":[{"Type":"NodeText","Data":"通常不太考虑，很多算法都是空间换时间。空间由很多部分组成："}]},{"ID":"20240920215336-5chcd16","Type":"NodeParagraph","Properties":{"id":"20240920215336-5chcd16","updated":"20240920215401"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image_20240409_221825_194"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image_20240409_221825_194-20240920215336-ov3i8jf.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20240920215055-ccgi9ik","Type":"NodeParagraph","Properties":{"id":"20240920215055-ccgi9ik","updated":"20240920215055"},"Children":[{"Type":"NodeText","Data":"在分析一段程序的空间复杂度时，只统计暂存数据、栈帧空间和输出数据三部分。统计方法就是计算整个程序中需要的所有空间大小。"}]},{"ID":"20240920215056-vrjdnj0","Type":"NodeParagraph","Properties":{"id":"20240920215056-vrjdnj0","updated":"20240920215056"},"Children":[{"Type":"NodeText","Data":"递归函数时才需要注意统计栈帧空间，函数递归调用会占用大量的空间。"}]},{"ID":"20240920215057-nnzlawd","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240920215057-nnzlawd","updated":"20240920215057"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"数组和链表"}]},{"ID":"20240920215058-9t5gzuu","Type":"NodeParagraph","Properties":{"id":"20240920215058-9t5gzuu","updated":"20240920215058"},"Children":[{"Type":"NodeText","Data":"跳过概念，需要知道一个点："},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"数组和链表对"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"缓存"},{"Type":"NodeText","Data":"的利用效率是不同的，主要体现在以下几个方面。"}]},{"ID":"20240920215059-vkj2k5t","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240920215059-vkj2k5t","updated":"20240920215059"},"Children":[{"ID":"20240920215060-ehvhwhj","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240920215060-ehvhwhj","updated":"20240920215060"},"Children":[{"ID":"20240920215061-vjzd9te","Type":"NodeParagraph","Properties":{"id":"20240920215061-vjzd9te","updated":"20240920215061"},"Children":[{"Type":"NodeText","Data":"占用空间：链表元素比数组元素占用空间更多，导致缓存中容纳的有效数据量更少。"}]}]},{"ID":"20240920215062-grzfrb1","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240920215062-grzfrb1","updated":"20240920215062"},"Children":[{"ID":"20240920215063-dd1681h","Type":"NodeParagraph","Properties":{"id":"20240920215063-dd1681h","updated":"20240920215063"},"Children":[{"Type":"NodeText","Data":"缓存行：链表数据分散在内存各处，而缓存是“按行加载”的，因此加载到无效数据的比例更高。"}]}]},{"ID":"20240920215064-8mkwj4e","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240920215064-8mkwj4e","updated":"20240920215064"},"Children":[{"ID":"20240920215065-jt7owd6","Type":"NodeParagraph","Properties":{"id":"20240920215065-jt7owd6","updated":"20240920215065"},"Children":[{"Type":"NodeText","Data":"预取机制：数组比链表的数据访问模式更具“可预测性”，即系统更容易猜出即将被加载的数据。"}]}]},{"ID":"20240920215066-dmzzcjy","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240920215066-dmzzcjy","updated":"20240920215066"},"Children":[{"ID":"20240920215067-l7bnkav","Type":"NodeParagraph","Properties":{"id":"20240920215067-l7bnkav","updated":"20240920215067"},"Children":[{"Type":"NodeText","Data":"空间局部性：数组被存储在集中的内存空间中，因此被加载数据附近的数据更有可能即将被访问。"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"总体而言，数组具有更高的缓存命中率，因此它在操作效率上通常优于链表。这使得在解决算法问题时，基于数组实现的数据结构往往更受欢迎。"}]}]}]},{"ID":"20240920215068-njoc291","Type":"NodeParagraph","Properties":{"id":"20240920215068-njoc291","updated":"20240920215068"},"Children":[{"Type":"NodeText","Data":"需要注意的是，高缓存效率并不意味着数组在所有情况下都优于链表。实际应用中选择哪种数据结构，应根据具体需求来决定。例如，数组和链表都可以实现“栈”数据结构（下一章会详细介绍），但它们适用于不同场景。"}]},{"ID":"20240920215069-67ylcc5","Type":"NodeParagraph","Properties":{"id":"20240920215069-67ylcc5","updated":"20240920215069"},"Children":[{"Type":"NodeText","Data":"在做算法题时，我们会倾向于选择基于数组实现的栈（比如C++自带的栈实现），因为它提供了更高的操作效率和随机访问的能力，代价仅是需要预先为数组分配一定的内存空间。"}]},{"ID":"20240920215070-ljigsef","Type":"NodeParagraph","Properties":{"id":"20240920215070-ljigsef","updated":"20240920215070"},"Children":[{"Type":"NodeText","Data":"如果数据量非常大、动态性很高、栈的预期大小难以估计，那么基于链表实现的栈更加合适。链表能够将大量数据分散存储于内存的不同部分，并且避免了数组扩容产生的额外开销。"}]},{"ID":"20240920215071-d2s3tz4","Type":"NodeParagraph","Properties":{"id":"20240920215071-d2s3tz4","updated":"20240920215071"},"Children":[{"Type":"NodeText","Data":"参考资料："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.hello-algo.com/","TextMarkTextContent":"Hello算法"}]}]}