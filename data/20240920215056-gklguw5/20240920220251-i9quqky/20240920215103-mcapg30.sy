{"ID":"20240920215103-mcapg30","Spec":"1","Type":"NodeDocument","Properties":{"id":"20240920215103-mcapg30","tags":"算法","title":"二分查找","type":"doc","updated":"20240920215103"},"Children":[{"ID":"20240920215104-639ewxt","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240920215104-639ewxt","updated":"20240920215104"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"基本逻辑"}]},{"ID":"20240920215105-zkwkd87","Type":"NodeParagraph","Properties":{"id":"20240920215105-zkwkd87","updated":"20240920215105"},"Children":[{"Type":"NodeText","Data":"在递增或者递减的一列数中，依次用目前区间最中间的数跟target比较，根据比较结果更新区间，再循环这个过程，知道找到最中间数=target或区间长度为0为止。"}]},{"ID":"20240920215106-wn1gts8","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240920215106-wn1gts8","updated":"20240920215106"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"基本写法"}]},{"ID":"20240920215107-7qm1jfi","Type":"NodeParagraph","Properties":{"id":"20240920215107-7qm1jfi","updated":"20240920215107"},"Children":[{"Type":"NodeText","Data":"定义target在区间[left,right]上，那么在left=right时任有意义，故循环条件是"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"left\u0026lt;=right"},{"Type":"NodeText","Data":"，right初始值为len-1，left为0."}]},{"ID":"20240920215108-9fcbwcy","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240920215108-9fcbwcy","updated":"20240920215108"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"class Solution {\npublic:\n    int search(vector\u003cint\u003e\u0026 nums, int target) {\n        int left = 0;\n        int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right]\n        while (left \u003c= right) { // 当left==right，区间[left, right]依然有效，所以用 \u003c=\n            int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2\n            if (nums[middle] \u003e target) {\n                right = middle - 1; // target 在左区间，所以[left, middle - 1]\n            } else if (nums[middle] \u003c target) {\n                left = middle + 1; // target 在右区间，所以[middle + 1, right]\n            } else { // nums[middle] == target\n                return middle; // 数组中找到目标值，直接返回下标\n            }\n        }\n        // 未找到目标值\n        return -1;\n    }\n};\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240920215109-60p040x","Type":"NodeParagraph","Properties":{"id":"20240920215109-60p040x","updated":"20240920215109"},"Children":[{"Type":"NodeText","Data":"还可以定义区间在[left,right)上，那么right初始值为len，left为0。循环条件就是"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"left\u0026lt;right"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240920215110-qziidiq","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240920215110-qziidiq","updated":"20240920215110"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"class Solution {\npublic:\n    int search(vector\u003cint\u003e\u0026 nums, int target) {\n        int left = 0;\n        int right = nums.size(); // 定义target在左闭右开的区间里，即：[left, right)\n        while (left \u003c right) { // 因为left == right的时候，在[left, right)是无效的空间，所以使用 \u003c\n            int middle = left + ((right - left) \u003e\u003e 1);\n            if (nums[middle] \u003e target) {\n                right = middle; // target 在左区间，在[left, middle)中\n            } else if (nums[middle] \u003c target) {\n                left = middle + 1; // target 在右区间，在[middle + 1, right)中\n            } else { // nums[middle] == target\n                return middle; // 数组中找到目标值，直接返回下标\n            }\n        }\n        // 未找到目标值\n        return -1;\n    }\n};\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240920215111-gjhgr9c","Type":"NodeParagraph","Properties":{"id":"20240920215111-gjhgr9c","updated":"20240920215111"},"Children":[{"Type":"NodeText","Data":"参考资料："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html","TextMarkTextContent":"代码随想录"}]}]}