# 长度最小子数组

Leetcode.209

> 给定一个含有 n 个正整数的数组和一个正整数 target 。  
> 找出该数组中满足其总和大于等于 target 的长度最小的 子数组 [nums<sub>l</sub>,..., nums<sub>r</sub>] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。

==滑动窗口==解决这个问题。

相比一下就能想出来的暴力解法，滑动窗口法精髓实质上是利用了以前的计算所计算出来的和，在基础上直接加减，从而降低复杂度。

```cpp
#include <bits/stdc++.h>
using namespace std;
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int first = 0,last =0,total = 0;
        int min = 999999999;
        for (; last<nums.size(); last++) {
            total+=nums[last];
            while (total-nums[first]>=target) {
                total-=nums[first];
                first++;
            }
            if (total >= target) {
                min = min<=(last-first+1)?min:(last-first+1);
            }
        }
        return min==999999999?0:min;
    }
};
```

‍
