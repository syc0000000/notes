{"ID":"20240923135826-nkm3gi6","Spec":"1","Type":"NodeDocument","Properties":{"custom-common-Halo-yaml":"---_esc_newline_created: '2024-09-23 13:58:26'_esc_newline_updated: '2024-09-23 14:41:21'_esc_newline_title: 搜索插入位置_esc_newline_slug: search-insertion-position-z241znw_esc_newline_permalink: siyuan://blocks/20240923135826-nkm3gi6_esc_newline_tags:_esc_newline_  - 算法_esc_newline_categories: []_esc_newline_---","id":"20240923135826-nkm3gi6","tags":"算法,题目","title":"搜索插入位置","type":"doc","updated":"20240923143723"},"Children":[{"ID":"20240923140131-j5yh1pe","Type":"NodeParagraph","Properties":{"id":"20240923140131-j5yh1pe","updated":"20240923140140"},"Children":[{"Type":"NodeText","Data":"Leetcode.35"}]},{"ID":"20240923135941-ypxq4hp","Type":"NodeBlockquote","Properties":{"id":"20240923135941-ypxq4hp","updated":"20240923135941"},"Children":[{"ID":"20240923135900-ezlqgh0","Type":"NodeParagraph","Properties":{"id":"20240923135900-ezlqgh0","updated":"20240923135941"},"Children":[{"Type":"NodeText","Data":"给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n请必须使用时间复杂度为 O(log n) 的算法。"}]},{"Type":"NodeBlockquoteMarker","Data":"\u003e"}]},{"ID":"20240923135936-69rm1ce","Type":"NodeParagraph","Properties":{"id":"20240923135936-69rm1ce","updated":"20240923143723"},"Children":[{"Type":"NodeText","Data":"实际上是"},{"Type":"NodeTextMark","TextMarkType":"mark","TextMarkTextContent":"二分查找"},{"Type":"NodeText","Data":"plus，关键是领悟如果结果不存在，此时应该返回的下标是left还是right或是left+1，right+1，middle。个人经验是在给定的实例里面脑算试一下，得到是到底应该返回哪个。\n答案是用二分查找的开区间模式最终返回right即可。"}]},{"ID":"20240923135949-74p02to","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240923135949-74p02to","updated":"20240923140030"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"class Solution {\npublic:\n    int searchInsert(vector\u003cint\u003e\u0026 nums, int target) {\n        int left = 0,right = nums.size();\n        int result = -1;\n        while (left\u003cright) {\n            int middle = (left+right)/2;\n            if (nums[middle]\u003etarget) {\n                right = middle;\n            }else if (nums[middle]\u003ctarget) {\n                left = middle + 1;\n            }else {\n                result = middle;\n                break;\n            }\n        }\n        if (result == -1) {\n            return right;\n        }else {\n            return result;\n        }\n    }\n};\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240923135936-1c83wer","Type":"NodeParagraph","Properties":{"id":"20240923135936-1c83wer","updated":"20240923140118"},"Children":[{"Type":"NodeText","Data":"相关知识点： "},{"Type":"NodeTextMark","TextMarkType":"block-ref","TextMarkBlockRefID":"20240920215103-mcapg30","TextMarkBlockRefSubtype":"s","TextMarkTextContent":"二分查找"}]}]}