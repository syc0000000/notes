{"ID":"20240923140209-34w45uu","Spec":"1","Type":"NodeDocument","Properties":{"custom-common-Halo-yaml":"---_esc_newline_created: '2024-09-23 14:02:09'_esc_newline_updated: '2024-09-23 14:41:09'_esc_newline_title: 长度最小子数组_esc_newline_slug: small-small-array-z1epzmr_esc_newline_permalink: siyuan://blocks/20240923140209-34w45uu_esc_newline_tags:_esc_newline_  - 算法_esc_newline_categories: []_esc_newline_---","id":"20240923140209-34w45uu","tags":"算法,题目","title":"长度最小子数组","type":"doc","updated":"20240923141406"},"Children":[{"ID":"20240923144048-lheov4h","Type":"NodeParagraph","Properties":{"id":"20240923144048-lheov4h","updated":"20240923144055"},"Children":[{"Type":"NodeText","Data":"Leetcode.209"}]},{"ID":"20240923140941-b6nccqd","Type":"NodeBlockquote","Properties":{"id":"20240923140941-b6nccqd","updated":"20240923141206"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240923140941-j28v6nr","Type":"NodeParagraph","Properties":{"id":"20240923140941-j28v6nr","updated":"20240923141206"},"Children":[{"Type":"NodeText","Data":"给定一个含有 n 个正整数的数组和一个正整数 target 。\n找出该数组中满足其总和大于等于 target 的长度最小的 子数组 [nums"},{"Type":"NodeTextMark","TextMarkType":"sub","TextMarkTextContent":"l"},{"Type":"NodeText","Data":",..., nums"},{"Type":"NodeTextMark","TextMarkType":"sub","TextMarkTextContent":"r"},{"Type":"NodeText","Data":"] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。"}]}]},{"ID":"20240923140944-4t0kiur","Type":"NodeParagraph","Properties":{"id":"20240923140944-4t0kiur","updated":"20240923143850"},"Children":[{"Type":"NodeTextMark","TextMarkType":"mark","TextMarkTextContent":"滑动窗口"},{"Type":"NodeText","Data":"解决这个问题。"}]},{"ID":"20240923141225-e16ld9h","Type":"NodeParagraph","Properties":{"id":"20240923141225-e16ld9h","updated":"20240923141406"},"Children":[{"Type":"NodeText","Data":"相比一下就能想出来的暴力解法，滑动窗口法精髓实质上是利用了以前的计算所计算出来的和，在基础上直接加减，从而降低复杂度。"}]},{"ID":"20240923144037-x8v9lgp","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240923144037-x8v9lgp","updated":"20240923144037"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"#include \u003cbits/stdc++.h\u003e\nusing namespace std;\nclass Solution {\npublic:\n    int minSubArrayLen(int target, vector\u003cint\u003e\u0026 nums) {\n        int first = 0,last =0,total = 0;\n        int min = 999999999;\n        for (; last\u003cnums.size(); last++) {\n            total+=nums[last];\n            while (total-nums[first]\u003e=target) {\n                total-=nums[first];\n                first++;\n            }\n            if (total \u003e= target) {\n                min = min\u003c=(last-first+1)?min:(last-first+1);\n            }\n        }\n        return min==999999999?0:min;\n    }\n};\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240923144037-neyn7r6","Type":"NodeParagraph","Properties":{"id":"20240923144037-neyn7r6","updated":"20240923144037"}}]}